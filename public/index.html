<html class="main-html" lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SCP Wallet</title>

  <link rel="canonical" href="https://getbootstrap.com/docs/5.0/examples/carousel/">

  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
  <link id="themeSheet" themeIndex="0" href="style/latest-style-light.css" rel="stylesheet">
  <link href="fontawesome/css/fontawesome.min.css" rel="stylesheet">
  <link href="fontawesome/css/all.min.css" rel="stylesheet">
  
  <!-- Functional Libraries (Cryptography, Hashing, Encryption, Encoding, etc) -->
  <script type="text/javascript" src="../scripts/aes-gcm.js"></script>

  <!-- Interface Framework Libraries (GUI, wallet management, networking, etc) -->
  <script type="text/javascript" src="../scripts/qrcode.js"></script>
  <script type="text/javascript" src="../scripts/settings.js"></script>
  <script type="text/javascript" src="../scripts/wallet.js"></script>
  <script type="text/javascript" src="../scripts/network.js"></script>
  <script type="text/javascript" src="js/switchPages.js"></script>

  <!-- SCP LIBRARY GOES BELOW -->
  <script type="text/javascript" src="../src/index.js"></script>
  <!-- SCP LIBRARY GOES ABOVE -->

  <script>window.$ = window.jQuery = require('jquery');</script>
</head>

<body>
  <div id="loginPage" class="page-gradient" style="display: block;">
    <div class="container marketing">
      <div class="verticalalign" style="padding-top: 5%;">
        <div class="vertical-center color-white">
          <center>
            <img id="loginLogo" src="imgs/sc-dark-bg.svg" style="height:50px;">
            <span id="versionLogin" style="position: static;color: white;opacity: 0.325;font-size: small;cursor: default;letter-spacing: 1px;margin-left: 1px;"></span>
            <br><br>
          </center>
          <div class="container">
            <div class="row align-items-center" style="height: 50%;">
              <div class="col-sm-10 offset-sm-1">
                <div class="login-card card-prop2 mb-4">
                  <div class="card-body font-gray">
                    <div class="login-page">
                      <center>
                        <h5 class="mb-3">Unlock your wallet</h5>
                        <br>
                        <div class="omrs-input-group" style="width:100%; margin-bottom:10px;">
                          <label style="display: flex;" class="omrs-input-underlined">
                            <input required id="pass1" type="password" autofocus>
                            <span class="omrs-input-label">Password</span>
                            <button onclick="switchLoginVisibility()" style="background-color: transparent;border-style: none;outline: none;">
                              <i id="pass1Visibility" class="fas fa-eye-slash"></i>
                            </button>
                          </label>
                        </div>
                      </center>

                      <script>
                        'use strict';
                        function switchLoginVisibility() {
                          if (domPass1Visibility.classList.contains("fa-eye-slash")) {
                            // Display pass
                            domPass1Visibility.classList.remove("fa-eye-slash");
                            domPass1Visibility.classList.add("fa-eye");
                            document.getElementById("pass1").setAttribute("type", "text");
                          } else {
                            // Hide pass
                            domPass1Visibility.classList.remove("fa-eye");
                            domPass1Visibility.classList.add("fa-eye-slash");
                            document.getElementById("pass1").setAttribute("type", "password");
                          }
                        }

                        $(document).ready(function(){
                          $('#pass1').keypress(function(e){
                            if(e.keyCode==13) {
                              finishEncryptedLogin();
                            }
                          });
                        });
                      </script>

                      <table class="mb-0" style="border:0;margin-top:15px;">
                        <tr class="info">
                          <td>
                            <i class="fas fa-info-circle" style="margin-right: 10px;margin-top: 4px;"></i>
                          </td>
                          <td>
                            Please remember to write down your password, if you lose it, StakeCube cannot recover your funds!
                          </td>
                        </tr>
                      </table>

                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let fDecrypted = false;
    let funcStarter = switchToDashboard;

    function finishLogin() {
      fDecrypted = true;
      // Reset password entry
      document.getElementById("pass1").value = "";
      // Hide login screen
      domLoginPage.style.display = "none";
      funcStarter();
      funcStarter = switchToDashboard;
      DB.setWallet(WALLET.toDB());
      // Give the cache a kick
      getBlockCount();
      getUnspentTransactions();
      // If an update is available, notify the user after a brief period
      if (isOutdated) {
        setTimeout(() => {
          M.toast({html: '<a style="cursor: pointer;" onclick="openExternalURL(\'https://github.com/stakecube/StakeCubeProtocol/releases/latest\')">An update is available!</a>', displayLength: 30000});
        }, 3 * 1000);
      }
    }

    function finishEncryptedLogin() {
      const nPass = document.getElementById("pass1").value;
      decryptWallet(nPass).then(done => {
        if (done) {
          finishLogin();
        } else {
          M.toast({html: 'Incorrect Password!', displayLength: 2000});
        }
      });
    }
  </script>

  <header id="guiHeader" style="display: none;">
    <nav class="navbar navbar-expand-md navbar-dark fixed-top navbar-colour font-weight-bold">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">
          <img onclick="switchToDashboard()" src="imgs/sc-dark-bg.svg" style="height:45px;">
          <span id="version" style="position: relative;color: white;opacity: 0.4;font-size: x-small;cursor: default;letter-spacing: 1px;bottom: 3px;"></span>
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
          aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarCollapse">
          <ul class="navbar-nav me-auto mb-2 mb-md-0">
            <li class="nav-item">
              <a class="nav-link active" id="dashboardBtn" aria-current="page" href="#" onclick="switchToDashboard()">
                Dashboard
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="sendBtn" onclick="switchToSend()">
                Send
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="receiveBtn" onclick="switchToReceive()">
                Receive
              </a>
            </li>
            <li class="nav-item" id="sigBtnMenu">
              <a class="nav-link" href="#" id="sigBtn" onclick="switchToSigs()">
                Sign / Verify
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="collectionsBtn" onclick="switchToViewCollection();renderNFTs(-1)">
                NFTs
              </a>
            </li>
            <li class="nav-item" id="2faBtnMenu">
              <a class="nav-link" href="#" id="2faBtn" onclick="switchToAuth()">
                2FA
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="createTokenBtn" onclick="switchToCreateToken()">
                Create token
              </a>
            </li>
          </ul>
          <form class="d-flex" style="margin-bottom:0px;">
            <a href="#" onclick="switchToSettings()"><i class="fas fa-cog fas-higher-contrast"></i></a>
          </form>
        </div>
      </div>
    </nav>
  </header>

  <script>
    'use strict';
    // GUI module imports
    const cElectron = require('electron');
    const clipboard = cElectron.clipboard;
    const dialog = cElectron.remote.dialog;
    const cMenu = cElectron.remote.Menu;
    const cMenuItem = cElectron.remote.MenuItem;
    let authenticator = require("otplib").authenticator;

    // WALLET STATE DATA
    let cachedTokens = [];
    let cachedOwnedNFTs = [];
    let cachedCollections = [];
    let cachedBlockCount = 0;
    let cachedActivity = [];
    let cachedActivityIS = [];
    let cachedCollectionsIS = []; 
    let cachedCoinDeltas = [];

    // Statistical / Informational data
    let valueUSD = 0;
    let currentSupply = 0;

    // Cached DOM elements
    let activityViewSCP = true;
    let domHeader;
    let domLoginPage;
    let domDashboardBtn;
    let domSendBtn;
    let domReceiveBtn;
    let dom2FABtn;
    let dom2FAMenu;
    let domSigBtn;
    let domSigMenu;
    let domSigSelector;
    let domSigMessageInput;
    let domSigOutput;
    let domSigAddress;
    let domSigAddressBar;
    let domSigSignature;
    let domSigSignatureBar;
    let domSigConfirmBtn;
    let domCreateTokenBtn;
    let domScpTokenErrors;
    let domScpTokenName;
    let domScpTokenTicker;
    let domScpTokenSupply;
    let domScpTokenPoSReward;
    let domScpTokenMinAge;
    let domScpCollectionName;
    let domScpCollectionMaxMints;
    let domScpCollectionProtected;
    let domScpTokenDeployBtn;
    let domScpTokenDeployArea;
    let domNFTCollectionsBtn;
    let domNFTBurnBtn;
    let domNFTTransferBtn;
    let domNFTMarketDetails;
    let domNFTMarketLast;
    let domNFTMarketHigh;
    let domNFTMarketLow;
    let domDashboardPage;
    let domSendPage;
    let domSigPage;
    let domReceivePage;
    let domAuthPage;
    let domStakingPage;
    let domSettingsPage;
    let domCreateTokenPage;
    let domCreateNftPage;
    let domScpNftMintBtn;
    let domViewCollection;
    let domCollections;
    let domCollectionsName;
    let domCollectionsList;
    let domViewNFT;
    let domNFTList;
    let domNftDetailTitle;
    let domNftDetailMintCount;
    let domNftDetailImg;
    let domNftDetailID;
    let domNftDetailCollection;
    let domNftDetailImageID;
    let domNftDetailOwner;
    let domNftDetailActivity;
    let domNftDetailActions;
    let domNftMintSubtitle;
    let domNftMintOpts;
    let domNftMintProgress;

    let domPass1Visibility;

    let domReceiveAddress;
    let domBalance;
    let domBalanceUSD;
    let domTokensList;
    let domSendingCoin;
    let domSendingBalance;
    let domActivityList;
    let domActivitySCC;
    let domActivitySCP;
    let domClaimAllBtn;
    let domWalletSelector;

    let domMarketcap;
    let domPrice;
    let domBlock;

    let domAuthDisplay;
    let domAuthImport;
    let domAuthTitle;
    let domAuthCode;
    let domAuthTime;
    let domAuthReset;

    let domStakingTitle;
    let domStakingSubtitle;
    let domStakingApy;
    let domStakingRewards;
    let domStakingRedeem;
    let domStakingRoi;

    // GUI Context Menu setup
    const contextMenu = cMenu.buildFromTemplate([
                   {
                      role: 'undo'
                   },
                   {
                      role: 'redo'
                   },
                   {
                      type: 'separator'
                   },
                   {
                      role: 'cut'
                   },
                   {
                      role: 'copy'
                   },
                   {
                      role: 'paste'
                   },
                   {
                      type: 'separator'
                   },
                   {
                      role: 'forceReload'
                   },
                   {
                      role: 'toggleDevTools'
                   },
    ]);

    window.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      contextMenu.popup(cElectron.remote.getCurrentWindow());
    }, false);

    function getMempoolDeltas(strCurrency) {
      let nDelta = 0;
      if (strCurrency === 'scc') {
        // TODO: Add SCC InstantSend mempool-deltas
      } else {
        const cToken = isFullnode ? TOKENS.getToken(strCurrency) : getCachedToken(strCurrency);
        if (cToken && !cToken.error) {
          for (const cActivity of cachedActivityIS) {
            if (cActivity.token.contract !== cToken.contract) continue;
            if (cActivity.type === 'received' || cActivity.type === 'staked') {
              nDelta += cActivity.amount;
            } else if (cActivity.type === 'sent') {
              nDelta -= cActivity.amount;
            }
          }
        }
      }
      return nDelta;
    }

    function hasMempoolStakes(contract) {
      let fStaked = false;
      const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
      if (cToken && !cToken.error) {
        for (const cActivity of cachedActivityIS) {
          if (cActivity.token.contract !== cToken.contract) continue;
          if (cActivity.type === 'staked') {
            fStaked = true;
          }
        }
      }
      return fStaked;
    }

    function addMockActivity(strType = "unknown", nAmount = 0, cToken) {
      const cActivity = {
          'id': null,
          'token': {
              'contract': cToken.contract,
              'ticker': cToken.ticker,
              'name': cToken.name
          },
          'block': 'Unconfirmed',
          'contract': cToken.contract,
          'account': WALLET.getActiveWallet().getPubkey(),
          'type': strType,
          'amount': nAmount,
      }
      cachedActivityIS.push(cActivity);
    }

    let cachedMempool = [];
    async function getMempoolActivity(account = false, cache = false) {
      if (!cache)
        cachedMempool = isFullnode ? await getFullMempool() : (JSON.parse(await NET.getMempoolLight()));
      const arrActivity = [];
      cachedCollectionsIS = [];
      // Loop all mempool TXs
      for (const cTX of cachedMempool) {
          // Loop all TX vouts
          for (const cVout of cTX.vout) {
              if (!cVout.scriptPubKey) continue;
              if (!cVout.scriptPubKey.hex) continue;
              // Scan the scriptPubKey for OP_RETURN (+ PUSHDATA)
              if (cVout.scriptPubKey.hex.startsWith('6a4c')) {
                  // Found an OP_RETURN! Parse the message from HEX to UTF-8
                  const rawHex = cVout.scriptPubKey.asm.substr(10);
                  const buf = Buffer.from(rawHex, 'hex');
                  const strOp = buf.toString('utf8');
                  if (!strOp.includes(' ')) continue;
                  const arrOp = strOp.split(' ');
                  const isLongData = strOp.length > 64;
                  let isUsingIndex = false;
                  if (UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount)) {
                      isUsingIndex = strOp.startsWith('id');
                      if (isUsingIndex)
                        arrOp[0] = Number(arrOp[0].substr(2));
                  }
                  // Let's check if this is a token deployment or creation
                  if (!isUsingIndex && arrOp[0].startsWith("SCPCREATE")) {
                    // SCP-4 Collections
                    if (arrOp[0].endsWith("4")) {
                      const cColl = new NFT.SCP4(cTX.txid, arrOp[1], Number(arrOp[2]), Number(arrOp[3]), WALLET.getActiveWallet().getPubkey());
                      cColl.totalNFTs = 0;
                      cColl.burnedNFTs = 0;
                      cColl.index = cachedCollections[cachedCollections.length - 1].index + 1 + (cachedCollectionsIS.length ? cachedCollectionsIS.length : 0);
                      cColl.mempool = true;
                      cachedCollectionsIS.push(cColl);
                    }
                  } else {
                    // This may be an SCP-4 NFT action, let's try to find the Collection
                    const cColl = getCachedCollection(arrOp[0]);
                    if (cColl) {
                      // Found the collection, determine the action
                      if (arrOp[1] === 'mint') {
                        // If we don't have this NFT, then add it to the collection cache
                        if (!cColl.nfts || !cColl.nfts.length) cColl.nfts = [];
                        if (!cColl.nfts.find(a => a.id === cTX.txid)) {
                          const cNFT = {
                            'id': cTX.txid,
                            'name': arrOp[2],
                            'imgUrl': arrOp[3],
                            'owner': WALLET.getActiveWallet().getPubkey(),
                            'mempool': true,
                            'activity': [{
                                'tx': cTX.txid,
                                'type': 'mint',
                                'from': null,
                                'to': WALLET.getActiveWallet().getPubkey(),
                                'block': (cTX.instantlock ? '⚡ C' : 'Unc') + 'onfirmed'
                            }]
                          }
                          cColl.nfts.push(cNFT);
                        }
                      } else if (arrOp[1] === 'transfer') {
                        // If we don't have this NFT, try to refresh the collection cache
                        if (!cColl.nfts || !cColl.nfts.length) {
                          cColl.nfts = [];
                          await fetchNFTs(cColl);
                        }
                        const cExistingNFT = cColl.nfts.find(a => a.id === arrOp[3]);
                        if (cExistingNFT) {
                          // NFT exists, so add the activity, if that also doesn't exist!
                          if (!cExistingNFT.activity.find(a => a.tx === cTX.txid)) {
                            cExistingNFT.owner = arrOp[2];
                            cExistingNFT.mempool = true;
                            cExistingNFT.activity.push({
                                'tx': cTX.txid,
                                'type': 'transfer',
                                'from': cTX.vout[1].scriptPubKey.addresses[0],
                                'to': arrOp[2],
                                'block': (cTX.instantlock ? '⚡ C' : 'Unc') + 'onfirmed'
                            });
                          }
                        }
                        if (cExistingNFT && cExistingNFT.owner === WALLET.getActiveWallet().getPubkey()) {
                          const cOwnedNFT = cachedOwnedNFTs.find(a => a.nft === cExistingNFT.id);
                          if (!cOwnedNFT) {
                            const cNewNFT = {
                                'nft': cExistingNFT.id,
                                'name': cExistingNFT.name,
                                'imgUrl': cExistingNFT.imgUrl,
                                'collection': cColl.contract,
                                'collectionIndex': cColl.index,
                                'collectionName': cColl.collectionName,
                                'activity': cExistingNFT.activity
                            }
                            cNewNFT.activity.push({
                                'tx': cTX.txid,
                                'type': 'transfer',
                                'from': cTX.vout[1].scriptPubKey.addresses[0],
                                'to': arrOp[2],
                                'block': (cTX.instantlock ? '⚡ C' : 'Unc') + 'onfirmed'
                            });
                            cachedOwnedNFTs.push(cNewNFT);
                          }
                        }
                      }
                    }
                  }
                  // If one of these flags are enabled, this is highly likely a normal token event
                  if (isFullnode && (isLongData || isUsingIndex)) {
                      // Ensure the token is valid and exists
                      const cToken = isFullnode ? TOKENS.getToken(arrOp[0]) : getCachedToken(arrOp[0]);
                      if (!cToken || cToken.error || cToken.supply <= 0) continue;
                      // Construct the caller's Activity object
                      const cActivity = {
                          'id': cTX.txid,
                          'token': {
                              'contract': cToken.contract,
                              'ticker': cToken.ticker,
                              'name': cToken.name
                          },
                          'block': (cTX.instantlock ? '⚡ C' : 'Unc') + 'onfirmed',
                          'contract': cToken.contract,
                          'account': cTX.vout[1].scriptPubKey.addresses[0],
                          'type': 'unknown',
                          'amount': 0
                      };
                      const cAccount = cActivity.account;
                      // Identify the transaction type
                      const operation = arrOp[1];
                      switch (operation) {
                      case 'mint':
                          cActivity.type = 'received';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      case 'burn':
                          cActivity.type = 'sent';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      case 'send':
                          // Sender activity
                          cActivity.type = 'sent';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          // Receiver activity
                          const cRecvActivity = JSON.parse(
                              JSON.stringify(cActivity));
                          cRecvActivity.type = 'received';
                          cRecvActivity.account = arrOp[3];
                          if (!account ||
                                  (account && arrOp[3] === account)) {
                              arrActivity.push(cRecvActivity);
                          }
                          break;

                      case 'redeem':
                          cActivity.type = 'staked';
                          const cStatus = isFullnode ? cToken.getStakingStatus(cToken.getAccount(cAccount)) :
                                                       JSON.parse(await NET.getLightStakingStatus(cToken.contract, cAccount));
                          cActivity.amount = cStatus.unclaimed_rewards;
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      default:
                          break;
                      }
                      // End the vout loop
                      break;
                  }
              }
          }
      }
      return arrActivity;
    }

    function getSyncPercentage() {
      // We measure based on our total SCP hash-cache, and our blocks since the start of SCP
      if (cachedBlockCount === 0 || chainHashesCache.length === 0) return 0;
      if (!currentScanBlock || !currentScanBlock.height) return 100;
      return percentOf(nCacheScannedBlks, (cachedBlockCount - nFirstBlock));
    }

    function getBalance(updateGUI = false) {
      const strPubkey = WALLET.getActiveWallet().getPubkey();
      const nBalance = WALLET.getBalance(strPubkey);

      // Update the GUI too, if chosen
      if (updateGUI) {
        // --- Update SCC Balances
        // Set the balance, and adjust font-size for large balance strings
        domBalance.innerText = nBalance.toLocaleString('en-GB', { maximumFractionDigits: 8 });
        if (valueUSD > 0)
          domBalanceUSD.innerText = (nBalance * valueUSD).toFixed(2);
        // And update the Receive page pubkey
        domReceiveAddress.innerText = strPubkey;

        // --- Update SCP token balances
        // Fetch all tokens owned by our account (strPubkey)
        if (isFullnode) {
          cachedTokens = TOKENS.getTokensByAccount(strPubkey);
        } else {
          getTokensByAccountLight(strPubkey);
          fetchNFTsByAddress(strPubkey);
        }

        // Update sync status
        if (chainHashesCache.length === 0 && isFullnode) {
          domTokensList.innerHTML = '<center style=\'margin-top:30px;\'><p>Loading SCP</p></center>';
        } else if (getSyncPercentage() < 99.99 && isFullnode) {
          domTokensList.innerHTML = '<center style=\'margin-top:30px;\'><p id="scpSyncing">SCP is still syncing (' + getSyncPercentage().toFixed(2) + '%)</p></center>';
        }

        // Update tokens list
        renderTokens();

        // Update activity widget
        if (isFullnode) {
          if (getSyncPercentage() >= 99.99) {
            cachedActivity = TOKENS.getActivityByAccount(strPubkey).reverse();
            rpcMain.call('getaddressdeltas', {
              'addresses': [strPubkey]
            }).then(res => {
              cachedCoinDeltas = res.reverse();
            }).catch(e => {
              // Fallback incase this node doesn't support address indexing
              getDeltasByAccountLight(strPubkey);
            });
          }
        } else {
          getActivityByAccountLight(strPubkey);
          getDeltasByAccountLight(strPubkey);
        }
        // Fetch SCC Deltas (a list of changes on this address)
        if (!isFullnode || isFullnode && getSyncPercentage() >= 99.99)
          renderActivity();
        // Render the NFT Elements, if the NFTs tab is active
        if (domNFTCollectionsBtn.className.includes('active')) {
          if (isFullnode) {
            renderCollections();
            renderNFTs();
          } else {
            NET.getLightCollectionHeaders().then(collRes => {
              // Add to cache if we don't already have any
              collRes = JSON.parse(collRes);
              collRes.map(addCachedCollection);
              
              renderCollections();
              if (nSelectedCollection !== -1) {
                // Specific contract selected, so load the full NFT supply details of the collection
                fetchNFTs(getCachedCollection(nSelectedCollection));
                renderNFTs();
              } else {
                renderNFTs();
              }
            });
          }
        } else if (!isFullnode) {
          // Just load the lighter data if we're tabbed-out, and don't render
          NET.getLightCollectionHeaders().then(collRes => {
            // Add to cache if we don't already have any
            collRes = JSON.parse(collRes);
            collRes.map(addCachedCollection);
          });
        }
      }

      return nBalance;
    }

    function renderTokens() {
      let strSendingSCC = '<option value="scc" data-thumbnail="imgs/circular-logo.svg">StakeCubeCoin (SCC)</option>';
      if (cachedTokens.length > 0) {
        // Dashboard
        let strDashTokens = "";
        // Send list
        let strSendTokens = "";
        for (const cToken of cachedTokens) {
          const nBal = (getMempoolDeltas(cToken.token.contract) + cToken.account.balance) / COIN;
          if (hideZeroBalance && nBal <= 0) continue;
          let strTokenButton = '';
          let strTokenStyle = '';
          let strTokenText = '';
          // Staking UI
          if (cToken.token.version === 2) {
            strTokenButton = 'onclick="switchToStaking(\'' + cToken.token.contract + '\')"';
            strTokenStyle = 'cursor:pointer;';
            const fStaked = hasMempoolStakes(cToken.token.contract);
            // If we haven't claimed stakes; display rewards!
            if (!fStaked) {
              const nRewards = cToken.account.unclaimed_balance / COIN;
              // Ensure we have unclaimed stakes, and the token has not hit max supply yet
              if (cToken.account.unclaimed_balance > 0 && cToken.token.supply + cToken.account.unclaimed_balance < cToken.token.maxSupply)
                strTokenText = ' <i style="opacity:0.5;">(+' + nRewards.toLocaleString('en-GB', { maximumFractionDigits: nRewards > 0.1 ? 2 : 8 }) + ')</i>';
            }
          }
          strDashTokens += '<div class="mt-3 mb-3 font-gray-2 font-weight-bold" style="font-size:15px; max-height: 32px;' + strTokenStyle + '" ' + strTokenButton + '><img src="imgs/circular-logo.svg" style="width:32px; height:32px; margin-right: 10px"><div class="d-inline-flex flex-column lh-sm" style="position: relative; top: -7px"><span>'+ formatName(cToken.token.ticker, 8) +'</span><span style="opacity: 0.75;font-size:0.75em;">SCP-' + cToken.token.version + '</span></div><span class="float-end theme-color-secondary">' + nBal.toLocaleString('en-GB', { maximumFractionDigits: (nBal > 1 ? 2 : 8) }) + strTokenText + '</span></div>';
          strSendTokens += '<option value="scptoken-' + cToken.token.contract + '" data-thumbnail="imgs/circular-logo.svg">' + formatName(cToken.token.name, 10) + ' (' + cToken.token.ticker + ')</option>';
        }
        domTokensList.innerHTML = strDashTokens;
        domSendingCoin.innerHTML = strSendingSCC + strSendTokens;
      } else {
        domTokensList.innerHTML = '<center style=\'margin-top:30px;\'><p>You have no tokens!</p></center>';
        domSendingCoin.innerHTML = strSendingSCC;
      }
    }

    function renderActivity() {
      // Our 'view' is either SCP or SCC, depending on the user's Activity settings
      const arrView = activityViewSCP ? cachedActivity : cachedCoinDeltas;
      let strActivityList = "";
      if (arrView.length > 0) {
        let arrTxView = [];
        // (SCC view ONLY) Sort the individual output deltas into per-transaction deltas
        if (!activityViewSCP) {
          for (const cDelta of arrView) {
            const cFoundTx = arrTxView.find(a => a.txid === cDelta.txid);
            if (cFoundTx) {
              // Found a prev. TX delta, merge the values
              cFoundTx.satoshis += cDelta.satoshis;
            } else {
              // Didn't find any TX deltas, add a new one (Deep Clone Primitives)
              arrTxView.push({
                satoshis: cDelta.satoshis,
                txid: cDelta.txid,
                index: cDelta.index,
                blockindex: cDelta.blockindex,
                height: cDelta.height,
                address: cDelta.address
              });
            }
          }
        } else {
          arrTxView = cachedActivityIS.concat(arrView);
        }
        // View SCP or SCC depending on the user's settings
        let i = 0;
        for (const cActivity of arrTxView) {
          if (!activityViewSCP && isScpTx(cActivity.txid)) continue;
          if (limitActivity && i >= 200) break;
          i++;
          const nValue = (cActivity.amount || cActivity.satoshis) / COIN;
          const strTx  = (cActivity.id || cActivity.txid);
          const strBlk = (cActivity.block || cActivity.height).toLocaleString('en-GB');
          const fIsNumBlk = Number.isInteger(cActivity.block || cActivity.height);
          //                                SCP Type         SCC Received or Sent
          const strType = activityViewSCP ? cActivity.type : (cActivity.satoshis >= 0 ? 'received' : 'sent');
          //                              (r)eceived                 (st)aked
          const fReceiveOrStake = strType.startsWith('r') || strType.startsWith('st');
          const strTypeColour = fReceiveOrStake ? "plus" : "minus";
          const strTypeSymbol = fReceiveOrStake ? "+" : "-";
          const strCoinTicker = cActivity.token ? cActivity.token.ticker : 'SCC';
          const strExplorerID = strTx ? 'style="cursor: pointer;" onclick="openExternalURL(\'https://www.coinexplorer.net/SCC/transaction/' + strTx + '\')"' : '';
          strActivityList += '<div class="mt-4 hover-darker" ' + strExplorerID + '><div class="float-start text-center">' + (fIsNumBlk ? 'Block ' : '') + ' ' + strBlk + '</div><span class="float-end ' + strTypeColour + '-balance-color font-weight-bold" style="position:relative; top:11px;"><i style="text-transform: capitalize;padding-right:5px;">' + strType + '</i> ' + strTypeSymbol + Math.abs(nValue).toLocaleString('en-GB', { maximumFractionDigits: nValue > 1 ? 2 : 8, minimumFractionDigits: 2 }) + ' ' + strCoinTicker + '</span></div><br><br><hr style="margin-top:5px; margin-bottom:5px;" class="font-gray">';
        }
        domActivityList.innerHTML = strActivityList;
      } else {
        domActivityList.innerHTML = "<center style='margin-top:30px;'><p>You have no activity!</p></center>";
      }
    }

    let strCollSearch = '';
    function renderCollections(strSearch = strCollSearch) {
      strCollSearch = strSearch;
      // Prep render cache
      let strRendering = '';
      // Get the current Collections source (full-node or lightwallet sources)
      const arrColls = isFullnode ? NFT.getCollectionPtr() : getCachedCollections();
      // Loop all SCP-4-like Collections and sort them into owned/unowned
      const arrOwned = [], arrUnowned = [];
      for (const cColl of arrColls) {
        if (strCollSearch.length && !(cColl.collectionName.toLowerCase().includes(strCollSearch) || cColl.creator.toLowerCase().includes(strCollSearch) || strCollSearch.includes(cColl.contract))) continue;
        // Check if this Collection was created by me
        if (cColl.creator === WALLET.getActiveWallet().getPubkey())
          arrOwned.push(cColl);
        else
          arrUnowned.push(cColl);
      }
      // Loop all sorted collections and render them into HTML chunks
      for (const cColl of arrOwned.concat(arrUnowned)) {
        // Calculate the supply (All existing NFTs that have not been burned)
        const nCardSupply = isFullnode ?
                              cColl.nfts.filter(a => a.owner !== null).length :
                              cColl.totalNFTs - cColl.burnedNFTs;
        // Calculate if minting additional NFTs is possible
        const fCanMint = (cColl.creator === WALLET.getActiveWallet().getPubkey() && ((cColl.mints < cColl.maxMints) || cColl.maxMints === -1));
        // Construct the render structure
        // TODO: Allow minting NFTS once a new upload solution is in place
        strRendering += `
                <tr>
                  <td style="cursor:pointer" onclick="switchToViewCollection();renderNFTs(${cColl.index});">${formatName(cColl.collectionName, 40)}</td>
                  <td>${nCardSupply.toLocaleString('en-GB')}</td>
                  <td title="${cColl.maxMints > 0 ? (cColl.maxMints - cColl.burnedNFTs).toLocaleString('en-GB') : "This collection has no NFT cap"}">${cColl.maxMints === -1 ? 'Unlimited' : formatAmount(cColl.maxMints - cColl.burnedNFTs)}</td>
                  <td><span class="subtext">${cColl.protected ? 'Yes' : 'No'}</span></td>
                  <td style="padding-top: 11px;">
                    ${false ? '<i class="fas fa-plus" style="margin-left: 10px;' + (cColl.mempool ? 'opacity:0.4;' : 'cursor: pointer;') + '" ' + (cColl.mempool ? 'title="Collection is confirming, you can mint once fully confirmed!"' : 'onclick="nSelectedCollection=' + cColl.index + ';switchToNftCreator();" title="Mint NFTs"') + '></i>' : ''}
                  </td>
                </tr>`;
      }
      // Draw the cache-constructed HTML
      domCollectionsList.innerHTML = strRendering;
    }

    let nSelectedCollection = -1;
    let strLastNFTRender = '';
    let strLastNftID = '';
    let strLastNftSearch = '';
    async function renderNFTs(nContract, strSearch = strLastNftSearch) {
      if (typeof nContract !== 'number') nContract = nSelectedCollection;
      nSelectedCollection = nContract;
      strLastNftSearch = strSearch;
      // Cache our address and refresh mempool activity
      const strAddr = WALLET.getActiveWallet().getPubkey();
      getMempoolActivity(strAddr, true);
      const domSearchbar = document.getElementById('nftSearch');
      // Prep render cache
      let strRendering = '';
      // Check if we're rendering all our NFTs, or a specific contract's NFTs
      if (nContract === -1) {
        // Set title
        domCollectionsName.innerText = 'My NFTs';
        // Hide the mint button
        domScpNftMintBtn.style.display = 'none';
        // Rendering all owned NFTs
        const arrNFTs = isFullnode ?
                          NFT.getAllNFTsByAccount(strAddr) :
                          cachedOwnedNFTs;
        if (!arrNFTs.length && !isFullnode) (await fetchNFTsByAddress()).map(arrNFTs.push);
        if (arrNFTs.length) {
          for (const cNFT of arrNFTs) {
            if (strLastNftSearch.length && !(cNFT.name.toLowerCase().includes(strLastNftSearch) || strLastNftSearch.includes(cNFT.nft) || strLastNftSearch.includes(cNFT.collection) || strLastNftSearch.includes(cNFT.imgUrl))) continue;
            strRendering += `
              <div class="col-3">
                <div class="card card-prop mb-3 nftCard" style="background: url(https://ipfs.qrypt.tech/ipfs/${cNFT.imgUrl}) no-repeat center;">
                  <div id="nft-${cNFT.nft}" class="card-body refresh-button" onclick="switchToViewNFT('${cNFT.nft}')">
                    <span class="badge nftname" title="${formatName(cNFT.name, 40)}">${formatName(cNFT.name, 26)}</span>
                  </div>
                </div>
              </div>`;
          }
          domSearchbar.style.display = 'block';
        } else {
          strRendering = `
            <center style="margin-top: 17.5vh;">
              <h4>You have no NFTs!</h4>
              <br>
              <button type="button" class="btn btn-theme btn-sm" onclick="switchToReceive()">Receive</button>
              or
              <button type="button" class="btn btn-theme btn-sm" onclick="switchToCreateToken('4')">Create your own</button>
            </center>`;
          domSearchbar.style.display = 'none';
        }
      } else {
        // Rendering NFTs from a contract
        const cColl = isFullnode ? NFT.getCollection(nContract) : getCachedCollection(nContract);
        // Set title
        domCollectionsName.innerText = formatName(cColl.collectionName, 40);
        // Cache the minting status
        const fCanMint = cColl.creator === strAddr && (cColl.maxMints === -1 || cColl.mints < cColl.maxMints);
        // Set the minting button, if eligible
        domScpNftMintBtn.style.display = (fCanMint && !cColl.mempool) ? 'inline-block' : 'none';
        // Ensure we have sufficient cache for more advanced data
        if (!cColl.nfts && !isFullnode) await fetchNFTs(cColl);
        // Construct the render structure
        if (cColl.nfts.length) {
          for (const cNFT of cColl.nfts.filter(a => a.owner !== null)) {
            if (strLastNftSearch.length && !(cNFT.name.toLowerCase().includes(strLastNftSearch) || cNFT.owner.toLowerCase().includes(strLastNftSearch) || strLastNftSearch.includes(cNFT.id) || strLastNftSearch.includes(cNFT.imgUrl))) continue;
            strRendering += `
              <div class="col-3">
                <div class="card card-prop mb-3 nftCard" style="background: url(https://ipfs.qrypt.tech/ipfs/${cNFT.imgUrl}) no-repeat center;${cNFT.owner !== strAddr ? `opacity:0.5;` : ``}">
                  <div id="nft-${cNFT.id}" class="card-body refresh-button" onclick="switchToViewNFT('${cNFT.id}')">
                    <span class="badge nftname" title="${formatName(cNFT.name, 40)}">${formatName(cNFT.name, 20)}</span>
                    ${cNFT.owner === strAddr ? `<i class="far fa-check-circle" style="position:absolute;right:0.75em;top:1.15em;color:#13c372eb!important;" title="You own this NFT!"></i>` : ``}
                  </div>
                </div>
              </div>`;
          }
          domSearchbar.style.display = 'block';
        } else {
          if (fCanMint) {
            strRendering = `
              <center style="margin-top: 17.5vh;">
                <h4>${cColl.mempool ? 'Your collection is confirming!' : 'Your new collection is empty!'}</h4>
                <br>
                ${
                  cColl.mempool ?
                  '<p style="opacity:0.75">Check back in a couple minutes and this collection should be ready for minting!</p>' :
                  '<button type="button" class="btn btn-theme btn-sm" onclick="switchToNftCreator()">Mint the first NFT</button>'
                }
              </center>`;
            domSearchbar.style.display = 'none';
          } else {
            strRendering = `
              <center style="margin-top: 17.5vh;">
                <h4>This collection is empty!</h4>
                <br>
                <p style="opacity:0.75">Check back in a while, maybe the creator will have minted cool stuff!</p>
              </center>`;
            domSearchbar.style.display = 'none';
          }
        }
      }
      // For performance and user sanity: Only render if the structure has changed
      if (strRendering === strLastNFTRender) return scrollToNFT();
      // Draw and cache the cache-constructed HTML
      domNFTList.innerHTML = strRendering;
      strLastNFTRender = strRendering;
      // If we just backed out from an NFT, then scroll to it'd ID, if it exists
      scrollToNFT();
    }

    function scrollToNFT() {
      if (strLastNftID && domViewCollection.style.display === "block") {
        const el = document.getElementById('nft-' + strLastNftID);
        if (el !== null) {
           el.scrollIntoView({behavior: "smooth", block: "center", inline: "nearest"});
           strLastNftID = '';
        }
      }
    }

    async function renderDetailedNFT(strID, fRefresh = true) {
      const strAddr = WALLET.getActiveWallet().getPubkey();
      // Find the NFT and Collection after refreshing mempool cache
      getMempoolActivity(strAddr, true);
      const cNFT = isFullnode ? NFT.getNFTbyId(strID) : getCachedNFT(strID);
      const cColl = isFullnode ? NFT.getCollection(cNFT.collectionIndex) : (typeof cNFT.collectionIndex === 'number' ? getCachedCollection(cNFT.collectionIndex) : getCachedCollectionByNftID(strID));
      // Select the NFT
      cSelectedNFT = getCachedNFT(cNFT.id || cNFT.nft, true);
      // Refresh the latest cache of this NFT's collection
      const isCached = domNftDetailID.innerText === strID;
      if (isCached) {
        await fetchNFTs(cColl);
      } else {
        fetchNFTs(cColl, fRefresh ? strID : null);
        // Fetch NFT prices and display them if they have any!
        domNFTMarketDetails.style.display = 'none';
        NET.getNftPrice(cNFT.id || cNFT.nft).then(cPrice => {
          if (cPrice && cPrice.result.length) {
            // Calculate all prices (last, high, low)
            const nLast = Number(cPrice.result[0].price);
            let nHigh = 0, nLow = 100000;
            for (const cTrade of cPrice.result) {
              const nPrice = Number(cTrade.price);
              if (nPrice > nHigh) nHigh = nPrice;
              if (nPrice < nLow) nLow = nPrice;
            }
            // Update the display!
            domNFTMarketLast.innerText = nLast.toLocaleString('en-GB') + ' SCC ($' + (nLast * valueUSD).toFixed(2) + ')';
            domNFTMarketHigh.innerText = nHigh.toLocaleString('en-GB') + ' SCC ($' + (nHigh * valueUSD).toFixed(2) + ')';
            domNFTMarketLow.innerText = nLow.toLocaleString('en-GB') + ' SCC ($' + (nLow * valueUSD).toFixed(2) + ')';
            domNFTMarketDetails.style.display = '';
          }
          // Sweet silence.
        }).catch(e => e);
      }
      // Cache the ownership status
      const fOwned = cNFT.owner ? cNFT.owner === strAddr : true;
      // Calculate supply and indexing for displaying
      const nCardSupply = isFullnode ?
                            cColl.nfts.filter(a => a.owner !== null).length :
                            cColl.totalNFTs - cColl.burnedNFTs;
      const nIndex = cColl.nfts ? cColl.nfts.findIndex(a => a.id === strID) : -1;
      // Render all elements
      if (!isCached) {
        domNftDetailTitle.innerText = cNFT.name;
        domNftDetailImg.src = 'https://ipfs.qrypt.tech/ipfs/' + cNFT.imgUrl;
        domNftDetailID.innerText = cNFT.nft || cNFT.id;
        domNftDetailCollection.setAttribute('onclick', 'switchToViewCollection();renderNFTs(' + cColl.index + ');');
        domNftDetailImageID.innerText = cNFT.imgUrl;
      }
      domNftDetailMintCount.innerHTML = '<b>#' + (nIndex === -1 ? '?' : (nIndex + 1)) + '</b><b style="opacity: 0.75">/' + (cColl.maxMints > 0 ? (cColl.maxMints - cColl.burnedNFTs) : nCardSupply) + '</b>';
      domNftDetailOwner.innerText = cNFT.owner || strAddr;
      strLastNftID = cNFT.nft || cNFT.id;
      // Pre-render activity
      let strRendering = '';
      // Deep-clone and reverse the activity list
      const arrActivity = JSON.parse(JSON.stringify(cNFT.activity)).reverse();
      for (const cActivity of arrActivity) {
        strRendering += `
          <tr>
            <td style="cursor:pointer" class="hover-darker" onclick="copyToClipboard('${cActivity.tx}', 'Transaction ID')">${formatName(cActivity.tx, 6)}</td>
            <td><span onclick="copyToClipboard('${cActivity.type}', 'Type')" class="badge hover-darker" style="background-color:#c36666;text-transform:capitalize;cursor:pointer;">${cActivity.type}</span></td>
            <td style="cursor:pointer" class="hover-darker" onclick="copyToClipboard('${cActivity.from}', 'Sender Address')">${cActivity.from !== null ? formatName(cActivity.from, 6) : 'Mint'}</td>
            <td style="cursor:pointer" class="hover-darker" onclick="copyToClipboard('${cActivity.to}', 'Receive Address')">${cActivity.to !== null ? formatName(cActivity.to, 6) : 'Burn'}</td>
            <td style="cursor:pointer" class="hover-darker" onclick="copyToClipboard('${cActivity.block}', 'Block Height')">${cActivity.block.toLocaleString('en-GB')}</td>
          </tr>`;
      }
      // Render the details page
      domNftDetailActivity.innerHTML = strRendering;
      // Render the action buttons, if owned by us
      domNftDetailActions.style.display = fOwned ? 'block' : 'none';
      if (cNFT.mempool) {
        domNFTTransferBtn.style.opacity = 0.4;
        domNFTTransferBtn.style.cursor = 'default';
        domNFTTransferBtn.setAttribute('data-bs-toggle', '');
        domNFTTransferBtn.setAttribute('title', 'This NFT is confirming, it cannot be transfered yet!');
      } else {
        domNFTTransferBtn.style.opacity = 1;
        domNFTTransferBtn.style.cursor = 'pointer';
        domNFTTransferBtn.setAttribute('data-bs-toggle', 'modal');
        domNFTTransferBtn.setAttribute('title', 'Transfer your NFT to someone else');
      }
      // Gray-out the 'burn' button if this collection is protected
      if (fOwned && cColl.protected) {
        domNFTBurnBtn.style.opacity = 0.4;
        domNFTBurnBtn.style.cursor = 'default';
        domNFTBurnBtn.setAttribute('data-bs-toggle', '');
        domNFTBurnBtn.setAttribute('title', 'This NFT is protected, it cannot be burned!');
      } else if (fOwned) {
        if (cNFT.mempool) {
          // NFT is owned, but confirming
          domNFTBurnBtn.style.opacity = 0.4;
          domNFTBurnBtn.style.cursor = 'default';
          domNFTBurnBtn.setAttribute('data-bs-toggle', '');
          domNFTBurnBtn.setAttribute('title', 'This NFT is confirming, it cannot be burned yet!');
        } else {
          // NFT is owned and confirmed
          domNFTBurnBtn.style.opacity = 1;
          domNFTBurnBtn.style.cursor = 'pointer';
          domNFTBurnBtn.setAttribute('data-bs-toggle', 'modal');
          domNFTBurnBtn.setAttribute('title', 'Burn (destroy) your NFT');
        }
      } else {
        // NFT is not owned
        domNFTBurnBtn.style.opacity = 0.4;
        domNFTBurnBtn.style.cursor = 'default';
        domNFTBurnBtn.setAttribute('data-bs-toggle', '');
        domNFTBurnBtn.setAttribute('title', '');
      }
    }

    function setActivityView(viewSCP) {
      activityViewSCP = viewSCP;
      domActivitySCC.style.opacity = viewSCP ? 0.4 : 1;
      domActivitySCP.style.opacity = viewSCP ? 1 : 0.4;
      domActivitySCC.style.cursor  = viewSCP ? 'pointer' : 'default';
      domActivitySCP.style.cursor  = viewSCP ? 'default' : 'pointer';
      renderActivity();
    }

    function getCachedToken(query) {
      const cToken = cachedTokens.find(a => a.token.contract === query);
      return typeof cToken !== 'undefined' ? cToken.token : false;
    }

    function getCachedAccount(ctoken) {
      const cToken = cachedTokens.find(a => a.token.contract === ctoken.contract);
      return typeof cToken !== 'undefined' ? cToken.account : false;
    }

    function getCachedCollection(query) {
      const cColl = getCachedCollections().find(a => a.contract === query || a.index === query);
      return cColl || false;
    }
    function getCachedCollections() {
      return cachedCollections.concat(cachedCollectionsIS);
    }
    
    function addCachedCollection(cNewColl) {
      // Try to find an existing one
      const cColl = getCachedCollection(cNewColl.contract);
      if (!cColl) {
        cachedCollections.push(cNewColl);
      } else {
        // Copy most data over from the new collection
        for (const key of Object.keys(cNewColl)) {
          cColl[key] = cNewColl[key];
        }
      }
      return true;
    }

    function getCachedCollectionByNftID(strID) {
      for (const cColl of getCachedCollections()) {
        const cNFT = (cColl.nfts && cColl.nfts.length) ? cColl.nfts.find(a => a.id === strID) : false;
        if (cNFT) return cColl;
      }
      return false;
    }

    function getCachedNFT(query, mine = false) {
      let cNFT;
      // First, we'll scan all other known NFTs for a match
      if (!mine) {
        for (const cColl of getCachedCollections()) {
          if (cColl.nfts && cColl.nfts.length) {
            cNFT = cColl.nfts.find(a => a.id === query);
            if (cNFT) break;
          }
        }
      }
      if (!cNFT) {
        // If not, check if the query matches a self-owned NFT
        cNFT = cachedOwnedNFTs.find(a => a.nft === query);
      }
      return cNFT;
    }

    function isScpTx(strTx) {
      return cachedActivity.findIndex(a => a.id === strTx) !== -1 || // SCP(1-2) transactions
             cachedOwnedNFTs.findIndex(a => a.nft === strTx) !== -1; // SCP-4 NFT deployments
    }

    async function fetchNFTs(cColl, renderID = null) {
      // Sync NFTs from the lightwallet server
      const cCollRes = JSON.parse(await NET.getLightCollection(cColl.contract));
      if (!cCollRes.error)
        addCachedCollection(cCollRes);
      // We check the Selected NFT is the same as the Render NFT, incase the user switched selection during a slow fetchNFTs(), preventing a race condition
      const strID = cSelectedNFT ? cSelectedNFT.id || cSelectedNFT.nft : '';
      if (renderID !== null && renderID === strID)
        renderDetailedNFT(renderID, false);
      return getCachedCollection(cColl.index);
    }

    async function fetchNFTsByAddress(strAddr = WALLET.getActiveWallet().getPubkey()) {
      // Sync addr-specific NFTs from the lightwallet server
      const arrNFTsRes = JSON.parse(await NET.getLightNFTsByAccount(strAddr));
      if (!arrNFTsRes.error)
        cachedOwnedNFTs = arrNFTsRes;
      return cachedOwnedNFTs;
    }

    function sendTransactionGUI() {
      const coinSelection = document.getElementById("sendingCoinVal").value;
      let nAmountSats = Math.round(Number(document.getElementById("sendAmount").value.trim()) * COIN);
      const sendAddress = document.getElementById("sendAddress").value.trim();
      if (!nAmountSats || !Number.isInteger(nAmountSats)) {
        return M.toast({html: 'Please enter a valid amount!', displayLength: 2000});
      }
      if (!sendAddress || sendAddress.length !== 34 || !sendAddress.startsWith("s")) {
        return M.toast({html: 'Please enter a valid address!', displayLength: 2000});
      }
      const strAddr = WALLET.getActiveWallet().getPubkey();
      const strPrivkey = WALLET.getActiveWallet().getPrivkey();
      if (coinSelection === "scc") {
        console.log("Constructing TX of value: " + (nAmountSats / COIN) + " SCC");
        const cTx = WALLET.sccjs.wallet.tx.transaction();
        // Inputs
        const usedUTXOs = WALLET.getCoinsToSpend(nAmountSats, false, strAddr);
        const nUTXOs = usedUTXOs.reduce((a, b) => a + b.sats, 0);
        for (const cUTXO of usedUTXOs)
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        if (nAmountSats > nUTXOs) return M.toast({html: 'Not enough funds!', displayLength: 2000});
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length * 4);
        const nSpent = nFee + nAmountSats;
        const nChange = nUTXOs - nSpent;
        const fNoChange = nAmountSats >= nUTXOs - nFee;
        if (fNoChange) {
          // We're sending alot! So we've got to deduct the fee from the send amount. There's not enough change to pay it with!
          nAmountSats = nAmountSats - nFee;
          // Destination output
          cTx.addoutput(sendAddress, nAmountSats / COIN);
          console.log('Adjusted SCC transaction amount to ' + (nAmountSats / COIN) + ' and removed change output to fit send-all.');
        } else {
          // Destination output
          cTx.addoutput(sendAddress, nAmountSats / COIN);
          // Add change output
          cTx.addoutput(strAddr, nChange / COIN);
        }
        // Broadcast
        cTx.sign(strPrivkey, 1).then(strSignedTx => {
          sendTransaction(strSignedTx, usedUTXOs);
        });
      } else {
        const strToken = coinSelection.substr(9);
        const cToken = isFullnode ? TOKENS.getToken(strToken) : getCachedToken(strToken);
        const cAccount = isFullnode ? cToken.getAccount(strAddr) : getCachedAccount(cToken);
        const nBal = getMempoolDeltas(cToken.contract) + cAccount.balance;
        if (nBal < nAmountSats) return M.toast({html: 'You don\'t have enough ' + cToken.ticker + '!', displayLength: 3000});
        console.log("Constructing SCP-" + cToken.version + " Transfer TX for: " + (nAmountSats / COIN) + " " + formatName(cToken.name, 12) + " (" + cToken.contract + ")");
        const cTx = WALLET.sccjs.wallet.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(10000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        const fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
        const idContract = fIndexed ? "id" + cToken.index : cToken.contract;
        cTx.addoutputburn(0.00000001, idContract + " send " + nAmountSats + " " + sendAddress);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = cUTXO.sats - nFee;
        cTx.addoutput(strAddr, nChange / COIN);
        // Broadcast
        cTx.sign(strPrivkey, 1).then(strSignedTx => {
          addMockActivity("sent", nAmountSats, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            M.toast({html: 'Transaction Sent!', displayLength: 1250});
            // Reset inputs
            document.getElementById("sendAmount").value = "";
            document.getElementById("sendAddress").value = "";
            if (isFullnodePtr()) {
              getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
            } else {
              NET.getMempoolActivityLight(strAddr).then(strRes => {
                cachedActivityIS = JSON.parse(strRes);
              });
              getUnspentTransactions();
            }
          });
        });
      }
    }

    function claimStakingRewards(contract) {
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
        const cAccount = isFullnode ? cToken.getAccount(strAddr) : getCachedAccount(cToken);
        console.log("Constructing SCP-" + cToken.version + " stake claim TX for " + (cAccount.unclaimed_balance / COIN).toLocaleString('en-GB') + " " + formatName(cToken.name, 12) + " (" + cToken.contract + ")");
        // Disable claim button
        domStakingRedeem.setAttribute('onclick', '');
        domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'Redeeming...';
        // Contruct SCP transaction
        const cTx = WALLET.sccjs.wallet.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(2000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        const fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
        const idContract = fIndexed ? "id" + cToken.index : cToken.contract;
        cTx.addoutputburn(0.00000001, idContract + " redeem");
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = cUTXO.sats - nFee;
        cTx.addoutput(strAddr, nChange / COIN);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          addMockActivity("staked", cAccount.unclaimed_balance, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            refreshStakingStatus(contract, false);
            M.toast({html: '🎉', displayLength: 2500});
            if (isFullnodePtr()) {
              getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
            } else {
              NET.getMempoolActivityLight(strAddr).then(strRes => {
                cachedActivityIS = JSON.parse(strRes);
              });
              getUnspentTransactions();
            }
          });
        });
    }

    let isClaiming = false;
    async function claimAll() {
      if (isClaiming) return;
      isClaiming = true;
      let nClaims = 0;
      const cWallet = WALLET.getActiveWallet();
      // Update UI
      domClaimAllBtn.style.opacity = 0.4;
      domClaimAllBtn.style.cursor = "default";
      // Search for stakeable tokens
      for (const cToken of cachedTokens) {
          if (cToken.token.version !== 2) continue;
          if (cToken.account.unclaimed_balance <= 0) continue;
          if (cToken.token.supply + cToken.account.unclaimed_balance >= cToken.token.maxSupply) continue;
          if (hasMempoolStakes(cToken.token.contract)) continue;
          // Let's claim the rewards!
          domClaimAllBtn.innerText = "Claiming " + cToken.token.ticker;
          // Init wallet & TX constructor
          const cTx = WALLET.sccjs.wallet.tx.transaction();
          // Asynchronously sync UTXOs with the network
          await WALLET.refreshUTXOs(cWallet.getPubkey());
          // Add input
          const cUTXO = WALLET.getCoinsToSpend(2000, true, cWallet.getPubkey())[0];
          if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
          // SCP output
          const fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
          const idContract = fIndexed ? "id" + cToken.token.index : cToken.token.contract;
          cTx.addoutputburn(0.00000001, idContract + " redeem");
          // Fee & Change output
          const nFee = WALLET.getFee(cTx.serialize().length);
          const nChange = cUTXO.sats - nFee;
          cTx.addoutput(cWallet.getPubkey(), nChange / COIN);
          // Sign & Broadcast
          const strSignedTx = await cTx.sign(cWallet.getPrivkey(), 1);
          addMockActivity("staked", cToken.account.unclaimed_balance, cToken.token);
          await WALLET.broadcastTx(strSignedTx);
          nClaims++;
          // Mark UTXO as spent
          cUTXO.spent = true;
          // Refresh token list
          renderTokens();
          // If no available UTXOs: Sleep to allow the mempool time to return our fresh UTXO set
          if (!WALLET.getAvailableUTXOs(cWallet.getPubkey()).length)
            await sleep(500);
        }
        await sleep(500);
        // Refresh the final UTXO set after a small sleep
        await WALLET.refreshUTXOs(cWallet.getPubkey());
        // Reset Claim All button
        domClaimAllBtn.innerText = "Claim All";
        domClaimAllBtn.style.cursor = "pointer";
        domClaimAllBtn.style.display = "none";
        domClaimAllBtn.style.opacity = 1;
        isClaiming = false;
        // Pull mempool transactions
        if (isFullnodePtr()) {
          cachedActivityIS = await getMempoolActivity(cWallet.getPubkey());
        } else {
          cachedActivityIS = JSON.parse(await NET.getMempoolActivityLight(cWallet.getPubkey()));
        }
        isClaiming = false;
        // Notify the user, finished!
        return M.toast({html: 'Redeemed ' + nClaims + ' rewards!', displayLength: 5000});
    }

    function deploySCP(version = 1, params = []) {
        if (!Number.isSafeInteger(version)) return console.error("SCP token must have a version integer!");
        if (params.length < 1) return console.error("SCP token deployment requires params!\nE.g; deploySCP(1, ['CatCoin', 'CAT', " + COIN + "])");
        // Ensure SCP params look atleast somewhat sane
        for (const param of params) {
          if (typeof param === 'string') {
            if (param.length === 0)  return M.toast({html: 'No empty strings allowed!', displayLength: 3000});
            if (param.length > 100)  return M.toast({html: 'No strings over 100 chars allowed!', displayLength: 4000});
            if (param.includes(' ')) return M.toast({html: 'No spaces allowed in SCP strings!', displayLength: 4000});
          } else
          if (typeof param === 'number') {
            // No floats allowed
            if (!Number.isInteger(param))    return M.toast({html: 'No floats allowed! Please use integers\nRef: ' + param, displayLength: 4000});
            // No integers larger than the safe integer 
            if (!Number.isSafeInteger(param)) return M.toast({html: 'An integer is too large, unsafe to deploy!\nRef: ' + ((param / COIN) / 1000000) + " mil", displayLength: 4000});
          } else {
            return M.toast({html: 'Unsupported param detected: ' + typeof param, displayLength: 3000});
          }
        }
        console.log("Constructing SCP-" + version + " deployment TX");
        const cTx = WALLET.sccjs.wallet.tx.transaction();
        // Inputs
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const nDeployCost = Math.round((nDeployFee * COIN) + 1000);
        const usedUTXOs = WALLET.getCoinsToSpend(nDeployCost, false, strAddr);
        const nUTXOs = usedUTXOs.reduce((a, b) => a + b.sats, 0);
        for (const cUTXO of usedUTXOs)
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        if (nDeployCost >= nUTXOs) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        // SCP output
        cTx.addoutputburn(0.00000001, "SCPCREATE" + version + " " + params.join(" "));
        // Static Deployment fee (Sent to the SCC burn address)
        cTx.addoutput(strDeployFeeDest, nDeployFee);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nSpent = Math.round(nFee + (nDeployFee * COIN));
        const nChange = nUTXOs - nSpent;
        cTx.addoutput(strAddr, nChange / COIN);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          WALLET.broadcastTx(strSignedTx).then(strTX => {
            usedUTXOs.forEach(cUTXO => cUTXO.spent = true);
            // Updates NFTs and other contracts
            getMempoolActivity(strAddr).then(res => {
              if (version === 4) {
                switchToCollections();
              }
            });
          });
        });
    }

    function mintSCP(contract, amount) {
        console.log("Constructing SCP mint TX for " + (amount / COIN).toLocaleString('en-GB'));
        const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const cTx = WALLET.sccjs.wallet.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(10000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        cTx.addoutputburn(0.00000001, contract + " mint " + amount);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = cUTXO.sats - nFee;
        cTx.addoutput(strAddr, nChange / COIN);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          if (cToken && !cToken.error)
            addMockActivity("received", amount, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            if (isFullnodePtr()) {
              getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
            } else {
              NET.getMempoolActivityLight(strAddr).then(strRes => {
                cachedActivityIS = JSON.parse(strRes);
              });
              getUnspentTransactions();
            }
            M.toast({html: 'Minting ' + (amount / COIN).toLocaleString('en-GB') + ' tokens!', displayLength: 3000});
          });
        });
    }

    function burnSCP(contract, amount) {
        console.log("Constructing SCP burn TX for " + (amount / COIN).toLocaleString('en-GB'));
        // Use our first UTXO, as the fees will be incredibly low anyway
        const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const cTx = WALLET.sccjs.wallet.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(10000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        cTx.addoutputburn(0.00000001, contract + " burn " + amount);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = cUTXO.sats - nFee;
        cTx.addoutput(strAddr, nChange / COIN);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          if (cToken && !cToken.error)
            addMockActivity("sent", amount, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            if (isFullnodePtr()) {
              getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
            } else {
              NET.getMempoolActivityLight(strAddr).then(strRes => {
                cachedActivityIS = JSON.parse(strRes);
              });
              getUnspentTransactions();
            }
            M.toast({html: 'Burning ' + (amount / COIN).toLocaleString('en-GB') + ' tokens!', displayLength: 3000});
          });
        });
    }

    function autofillSendingAmount() {
      document.getElementById("sendAmount").value = domSendingBalance.innerText.replace(/,/g, '');
    }

    function refreshSendBalance() {
      // Update available balance display
      const strPubkey = WALLET.getActiveWallet().getPubkey();
      let nSendBalanceDisplay = 0;
      const strCurrency = document.getElementById("sendingCoinVal").value;
      if (strCurrency === "scc") {
        nSendBalanceDisplay = WALLET.getBalance(strPubkey);
      } else {
        const strToken = strCurrency.substr(9);
        const cToken = isFullnode ? TOKENS.getToken(strToken) : getCachedToken(strToken);
        const cAccount = isFullnode ? cToken.getAccount(strPubkey) : getCachedAccount(cToken);
        const nBal = getMempoolDeltas(cToken.contract) + cAccount.balance;
        nSendBalanceDisplay = nBal / COIN;
      }
      domSendingBalance.innerText = nSendBalanceDisplay.toLocaleString('en-GB', { maximumFractionDigits: 8 });
    }

    function refreshSyncStatus() {
      let domScpSyncing = document.getElementById("scpSyncing");
      const syncPercent = getSyncPercentage();
      if (syncPercent > 99.99) {
        // Sync is close enough to being finished, stop checking and load the tokens!
        clearInterval(syncStatusInterval);
        getBalance(true);
      }
      if (domScpSyncing) {
        domScpSyncing.innerText = 'SCP is still syncing (' + syncPercent.toFixed(2) + '%)';
      } else if (syncPercent > 0) {
        getBalance(true);
      }
    }

    function getStakingAccountPacked(strContract, fRefresh = true) {
      const strPubkey = WALLET.getActiveWallet().getPubkey();
      const cToken = isFullnode ? TOKENS.getToken(strContract) : getCachedToken(strContract);

      // Lightwallets should async-refresh their status every call
      if (!isFullnode && fRefresh) getStakingStatusLight(strContract, strPubkey);

      return [
        cToken,
        //           Fullnode                            Lightwallet
        isFullnode ? cToken.getAccount(strPubkey)      : getCachedAccount(cToken),
        isFullnode ? cToken.getStakingStatus(cAccount) : cStakingStatus
      ];
    }

    let currentStakingToken = '';
    let cStakingStatus;
    function refreshStakingStatus(contract, fRefresh = true) {
      const strPubkey = WALLET.getActiveWallet().getPubkey();
      const [cStakeToken, cStakeAcc] = getStakingAccountPacked(contract, fRefresh);

      // Populate static data if available (name, ticker, etc)
      domStakingTitle.innerText = cStakeToken ? formatName(cStakeToken.name, 18) + " (" + formatName(cStakeToken.ticker, 6) + ")"
                                                  : "Loading...";

      // Put token + account info on the Staking Page on this refresh!
      if ((cStakeToken && cStakeAcc && cStakingStatus) && cStakingStatus.enabled) {
        // Run a quick'n'dirty APY calculation based on the current weight reward
        const nReward = cStakeToken.inflation * cStakingStatus.weight;
        const nTotalRewards = cStakeAcc.unclaimed_balance / COIN;
        // Also check to ensure we haven't hit the max supply yet
        if (cStakeToken.supply + cStakeAcc.unclaimed_balance >= cStakeToken.maxSupply)
        {
          domStakingApy.innerText = "0%";
          domStakingRoi.innerText = "";
          domStakingSubtitle.innerText = formatName(cStakeToken.name, 12) + " has hit it's max supply of " + (cStakeToken.maxSupply / COIN).toLocaleString('en-GB', { maximumFractionDigits: 8 }) + " " + formatName(cStakeToken.ticker, 6)  + "!";
          domStakingRewards.innerText = "Cap Reached";
          domStakingRedeem.setAttribute('onclick', '');
          if (!domStakingRedeem.classList.contains('disabled'))
            domStakingRedeem.classList.add('disabled');
          domStakingRedeem.innerText = 'No Stakes to Claim';
        } else {
          const fStaked = hasMempoolStakes(cStakeToken.contract);
          const nAPY = percentOf((nReward * 720) * 365, cStakeAcc.balance);
          if (nAPY > 0.01 && nReward > 1) {
            domStakingApy.innerText = nAPY.toLocaleString('en-GB', { maximumFractionDigits: (nAPY > 100 ? 0 : 2) }) + "%";
            domStakingRoi.innerText = "or a ROI of " + percentOf(cStakeAcc.unclaimed_balance, cStakeAcc.balance).toLocaleString('en-GB', { maximumFractionDigits: 2 }) + "%";
          } else {
            domStakingApy.innerText = "---";
            domStakingRoi.innerText = "";
          }
          domStakingSubtitle.innerText = "You've been staking for " + (cStakingStatus.age - cStakeToken.minAge).toLocaleString('en-GB') + " blocks and earned...";
          if (fStaked) {
            domStakingRewards.innerText = '0 ' + formatName(cStakeToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', '');
            if (!domStakingRedeem.classList.contains('disabled'))
              domStakingRedeem.classList.add('disabled');
            domStakingRedeem.innerText = 'No Stakes to Claim';
          } else if (cStakeAcc.unclaimed_balance > 0) {
            domStakingRewards.innerText = nTotalRewards.toLocaleString('en-GB', { maximumFractionDigits: nTotalRewards > 1 ? 4 : 8}) + " " + formatName(cStakeToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', 'claimStakingRewards("' + contract + '")');
            domStakingRedeem.classList.remove('disabled');
            domStakingRedeem.innerText = 'Claim Rewards';
          } else {
            domStakingRewards.innerText = '0 ' + formatName(cStakeToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', '');
            if (!domStakingRedeem.classList.contains('disabled'))
              domStakingRedeem.classList.add('disabled');
            domStakingRedeem.innerText = 'No Stakes to Claim';
          }
        }
      } else if (cStakeToken && cStakeAcc && cStakingStatus) {
        domStakingApy.innerText = "---";
        domStakingRoi.innerText = "";
        domStakingSubtitle.innerText = "Your tokens need another " + (cStakeToken.minAge - cStakingStatus.age).toLocaleString('en-GB') + " blocks to mature before earning stakes!";
        domStakingRewards.innerText = "0 " + cStakeToken.ticker;
        domStakingRedeem.setAttribute('onclick', '');
        if (!domStakingRedeem.classList.contains('disabled'))
          domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'No Stakes to Claim';
      } else {
        domStakingApy.innerText = "---";
        domStakingRoi.innerText = "";
        domStakingSubtitle.innerText = "Loading...";
        domStakingRewards.innerText = "...";
        domStakingRedeem.setAttribute('onclick', '');
        if (!domStakingRedeem.classList.contains('disabled'))
          domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'No Stakes to Claim';
      }
    }

    async function createAdditionalAccount() {
      // Create a new multi-wallet account
      const cWallet = await WALLET.createWallet();

      // Load the new wallet and save to DB
      const nWalletIndex = WALLET.getWalletIndexByPubkey(cWallet.getPubkey());
      WALLET.setActiveWallet(nWalletIndex);
      DB.setWallet(WALLET.toDB());

      // Nuke all wallet states
      cachedActivity = [];
      cachedActivityIS = [];
      cachedCoinDeltas = [];
      cachedOwnedNFTs = [];
      cachedTokens = [];

      // Append the wallet to the multi-wallet switcher
      const cOption = document.createElement("option");
      cOption.text = cWallet.getPubkey();
      domWalletSelector.add(cOption);

      // Feedback!
      M.toast({html: 'Account #' + WALLET.countWallets() + ' created! (' + cWallet.getPubkey().substr(0, 5) + '...)', displayLength: 3500});
    }

    function import2FA() {
      const strNewSecret = document.getElementById("authSecretImport").value;
      const testToken = authenticator.generate(strNewSecret);
      if (testToken && testToken.toString().length === 6) {
        WALLET.set2FAkey(strNewSecret);
        DB.setWallet(WALLET.toDB());
      }
    }

    function remove2FA() {
      WALLET.set2FAkey("");
      DB.setWallet(WALLET.toDB());
      refreshAuthenticator();
    }

    let lastAuthCode = null;
    function refreshAuthenticator() {
      const checkForSecret = localStorage.getItem("authsecret");
      if (checkForSecret) {
        WALLET.set2FAkey(checkForSecret);
        localStorage.removeItem("authsecret");
        console.log("DB: Migrated 2FA LS to Backend DB!");
        DB.setWallet(WALLET.toDB());
      }
      const strSecret = WALLET.get2FAkey();
      if (!strSecret) {
        // No authentication linked
        domAuthImport.style.display = "";
        domAuthDisplay.style.display = "none";
        domAuthTitle.innerText = "Setup your 2FA";
        domAuthReset.style.display = "none";
      } else {
        // Auth code already imported
        domAuthImport.style.display = "none";
        domAuthDisplay.style.display = "";
        domAuthTitle.innerText = "Login using 2FA";
        domAuthReset.style.display = "";
        // Fetch the current code
        const authCode = authenticator.generate(strSecret);
        if (lastAuthCode !== authCode)
          domAuthCode.innerText = authCode;
        const authTimeRemaining = authenticator.timeRemaining()
        domAuthTime.innerText = authTimeRemaining + " second" + (authTimeRemaining === 1 ? "" : "s") + " remaining until next code";
        lastAuthCode = authCode;
      }

      // Also use this chance to update the Staking page, if it's open
      if (domStakingPage.style.display === "block" && currentStakingToken) {
        refreshStakingStatus(currentStakingToken);
      }

      // Also use this to update the Claim All button's visibility
      if (!isFullnode || getSyncPercentage() >= 99.99) {
        let nPendingStakes = 0;
        for (const cToken of cachedTokens) {
          if (cToken.token.version !== 2) continue;
          if (cToken.account.unclaimed_balance <= 0) continue;
          if (cToken.token.supply + cToken.account.unclaimed_balance >= cToken.token.maxSupply) continue;
          if (hasMempoolStakes(cToken.token.contract)) continue;
          nPendingStakes++;
        }
        if (nPendingStakes > 1) {
          domClaimAllBtn.style.display = "inline-block";
        } else if (domClaimAllBtn.style.display !== "none") {
          domClaimAllBtn.style.display = "none";
        }
      }
    }

    function copyToClipboard(text, name) {
      clipboard.writeText(text);
      M.toast({html: name + ' copied to Clipboard!', displayLength: 2000});
    }

    function openExternalURL(url) {
      require("electron").shell.openExternal(url);
    }

    function showFileInExplorer(path) {
      require("electron").shell.showItemInFolder(path);
    }

    function formatName(name, limit) {
      return (name.length > limit ? name.substr(0, limit) + "…" : name).trim();
    }

    function formatAmount(n) {
      if      (n >= 1000000000000000) return (n / 1000000000000000).toLocaleString('en-GB', {maximumFractionDigits: 2}) + "Q";
      else if (n >= 1000000000000) return (n / 1000000000000).toLocaleString('en-GB', {maximumFractionDigits: 2}) + "T";
      else if (n >= 1000000000) return (n / 1000000000).toLocaleString('en-GB', {maximumFractionDigits: 2}) + "B";
      else if (n >= 1000000) return (n / 1000000).toLocaleString('en-GB', {maximumFractionDigits: 2}) + "M";
      else return n.toLocaleString('en-GB', {maximumFractionDigits: 8});
    }

    function percentOf(partial, full) {
      return (partial / full) * 100;
    }

    function percentChange(decrease, oldNumber) {
      return (decrease / oldNumber) * 100;
    }

    const sleep = (milliseconds) => {
      return new Promise(resolve => setTimeout(resolve, milliseconds));
    }

    setInterval(() => {
      // Check block count + UTXO sync every 10 seconds
      getBlockCount();
      const strAddr = WALLET.getActiveWallet().getPubkey();
      if (strAddr) {
        getUnspentTransactions();
        if (!isFullnodePtr()) {
          // Fetches SCP-1 and SCP-2 activity
          NET.getMempoolActivityLight(strAddr).then(strRes => {
            cachedActivityIS = JSON.parse(strRes);
          });
          // Updates NFTs and other contracts
          if (domViewNFT.style.display === "block") {
            getMempoolActivity(strAddr).then(res => {
              renderDetailedNFT(domNftDetailID.innerText);
            });
          }
        }
      }
      // Update Dashboard stats
      if (valueUSD > 0) {
        domBalanceUSD.innerText = (getBalance() * valueUSD).toFixed(2);
        domPrice.innerText = "$" + valueUSD.toFixed(2);
        if (currentSupply > 0)
          domMarketcap.innerText = "$" + (currentSupply * valueUSD).toLocaleString('en-GB', { maximumFractionDigits: 0});
      } else if (!fPriceAPI) {
        domPrice.innerText = 'Unknown (API down)';
        domMarketcap.innerText = 'Unknown (API down)';
      }
      // Fetch price and supply info
      getCoinValue();
      getCoinSupply();
    }, 10000);

    // Refresh syncing status
    let syncStatusInterval = setInterval(refreshSyncStatus, 200);

    // Refresh 2FA system
    setInterval(refreshAuthenticator, 1000);

    onload = () => {
      // Cache all our UI elements
      domTheme = document.getElementById("themeSheet");
      domThemeButton = document.getElementById("themeButton");
      // Initialize theme from disk
      loadTheme();
      domHeader = document.getElementById("guiHeader");
      domLoginPage = document.getElementById("loginPage");
      domPass1Visibility = document.getElementById("pass1Visibility");
      domDashboardPage = document.getElementById('dashboardPage');
      domSendPage = document.getElementById('sendPage');
      domSigPage = document.getElementById('sigPage');
      domSigSelector = document.getElementById('sigType');
      domSigMessageInput = document.getElementById('signerMessage');
      domSigOutput = document.getElementById('signerOutput');
      domSigAddressBar = document.getElementById('signerAddressBar');
      domSigAddress = document.getElementById('signerAddress');
      domSigSignatureBar = document.getElementById('signerSignatureBar');
      domSigSignature = document.getElementById('signerSignature');
      domSigConfirmBtn = document.getElementById('signBtn');
      domReceivePage = document.getElementById('receivePage');
      domAuthPage = document.getElementById('authPage');
      domStakingPage = document.getElementById('stakingPage');
      domSettingsPage = document.getElementById('settingsPage');
      domCreateTokenPage = document.getElementById('createTokenPage');
      domCreateNftPage = document.getElementById('createNftPage');
      domScpNftMintBtn = document.getElementById('scpNftMintBtn');
      domViewCollection = document.getElementById('viewCollection');
      domCollections = document.getElementById('NFTCollections');
      domCollectionsName = document.getElementById('collectionName');
      domCollectionsList = document.getElementById('collectionsList');
      domViewNFT = document.getElementById('viewNFT');
      domNFTList = document.getElementById('nftList');
      domAuthDisplay = document.getElementById('authDisplay');
      domAuthImport = document.getElementById('authImport');
      domAuthTitle = document.getElementById('authTitle');
      domReceiveAddress = document.getElementById("receiveAddress");
      domAuthCode = document.getElementById("authCode");
      domAuthTime = document.getElementById("authTime");
      domAuthReset = document.getElementById("authReset");
      domBalance = document.getElementById("guiBalance");
      domBalanceUSD = document.getElementById("balanceUSD");
      domTokensList = document.getElementById("dashboardTokens");
      domSendingCoin = document.getElementById("sendingCoin");
      domSendingBalance = document.getElementById("sendingCoinBalance");
      domPrice = document.getElementById("dashboardPrice");
      domMarketcap = document.getElementById("dashboardMarketcap");
      domBlock = document.getElementById("dashboardBlock");
      domDashboardBtn = document.getElementById("dashboardBtn");
      domActivityList = document.getElementById("activityList");
      domActivitySCC = document.getElementById("domActivitySCC");
      domActivitySCP = document.getElementById("domActivitySCP");
      domClaimAllBtn = document.getElementById("domClaimAllBtn");
      domWalletSelector = document.getElementById("walletSelector");
      domScpTokenDeployArea = document.getElementById('scpTokenDeployArea');
      domNFTBurnBtn = document.getElementById('nftBurnBtn');
      domNFTTransferBtn = document.getElementById('nftTransferBtn');
      domNFTMarketDetails = document.getElementById('nftMarketDetails');
      domNFTMarketLast = document.getElementById('nftMarketLast');
      domNFTMarketHigh = document.getElementById('nftMarketHigh');
      domNFTMarketLow = document.getElementById('nftMarketLow');
      domSendBtn = document.getElementById("sendBtn");
      domReceiveBtn = document.getElementById("receiveBtn");
      dom2FABtn = document.getElementById("2faBtn");
      domSigBtn = document.getElementById("sigBtn");
      domCreateTokenBtn = document.getElementById("createTokenBtn");
      domScpTokenErrors = document.getElementById("scpTokenErrors");
      domScpTokenName = document.getElementById("scpTokenName");
      domScpTokenTicker = document.getElementById("scpTokenTicker");
      domScpTokenSupply = document.getElementById("scpTokenSupply");
      domScpTokenPoSReward = document.getElementById("scpTokenPoSReward");
      domScpTokenMinAge = document.getElementById("scpTokenMinAge");
      domScpCollectionName = document.getElementById('scpCollectionName');
      domScpCollectionMaxMints = document.getElementById('scpCollectionMaxMints');
      domScpCollectionProtected = document.getElementById('scpCollectionProtected');
      domScpTokenDeployBtn = document.getElementById("scpTokenDeployBtn");
      domNFTCollectionsBtn = document.getElementById("collectionsBtn");
      domNftDetailTitle = document.getElementById('nftDetailTitle');
      domNftDetailMintCount = document.getElementById('nftDetailMintCount');
      domNftDetailImg = document.getElementById('nftDetailImg');
      domNftDetailID = document.getElementById('nftDetailID');
      domNftDetailCollection = document.getElementById('nftDetailCollection');
      domNftDetailImageID = document.getElementById('nftDetailImageID');
      domNftDetailOwner = document.getElementById('nftDetailOwner');
      domNftDetailActivity = document.getElementById('nftDetailActivity');
      domNftDetailActions = document.getElementById('nftDetailActions');
      domNftMintSubtitle = document.getElementById('nftMintSubtitle');
      domNftMintOpts = document.getElementById('nftMintOpts');
      domNftMintProgress = document.getElementById('nftMintProgress');
      dom2FAMenu = document.getElementById("2faBtnMenu");
      domSigMenu = document.getElementById("sigBtnMenu");
      domStakingTitle = document.getElementById("stakingTitle");
      domStakingSubtitle = document.getElementById("stakingSubtitle");
      domStakingApy = document.getElementById("stakingApy");
      domStakingRoi = document.getElementById("stakingRoi");
      domStakingRewards = document.getElementById("stakingRewards");
      domStakingRedeem = document.getElementById("stakingRedeem");
      // Load settings from disk
      loadSettings();
      // Apply UI settings
      if (!displayDevMenu)
        domCreateTokenBtn.style.display = "none";
      if (!display2FAMenu)
        dom2FAMenu.style.display = "none";
      cElectron.ipcRenderer.send('changeMinToTray', minToTray);
      // Don't need to cache these as it's just one-time use
      if (npmPackage) {
        document.getElementById("version").innerText = "v" + npmPackage.version;
        document.getElementById("versionLogin").innerText = "v" + npmPackage.version;
      } else {
        document.getElementById("version").style.display = "none";
        document.getElementById("versionLogin").style.display = "none";
      }
      switchToLogin();
      init().then(() => {
        // Check for a selected wallet, if one exists, pull up the login screen!
        let cWallet = WALLET.getActiveWallet() || new WALLET.Wallet();
        if (cWallet.getPrivkeyEnc() || cWallet.getPrivkey()) {
          // Hook the wallet selector into the live wallet system
          domWalletSelector.onchange = (evt) => {
            // Find the wallet index by the selected pubkey
            const nWalletIndex = WALLET.getWalletIndexByPubkey(evt.srcElement.value);
            // Set as active wallet and save to DB
            WALLET.setActiveWallet(nWalletIndex);
            DB.setWallet(WALLET.toDB());
            // Nuke all wallet states
            cachedActivity = [];
            cachedActivityIS = [];
            cachedCoinDeltas = [];
            cachedOwnedNFTs = [];
            cachedTokens = [];
            // Force a full cache refresh
            getBalance(true);
            // Force an NFTs re-render since the NFT updates deactivate when hidden
            renderNFTs(-1);

            // Feedback!
            if (WALLET.getActiveWallet().getPrivkey()) {
              // We have a private key, so simply notify of a successful switch
              M.toast({html: 'Switched account (' + WALLET.getActiveWallet().getPubkey().substr(0, 5) + '...)', displayLength: 3500});
            } else {
              // We don't have a private key, so most likely an encrypted wallet: prompt for login and clarify!
              switchToLogin();
              M.toast({html: 'The selected account is locked, password required!', displayLength: 5500});
            }
          }
          // Add all wallets to the settings selector
          for (const cSelectorWallet of WALLET.getWalletsPtr()) {
            const cOption = document.createElement("option");
            cOption.text = cSelectorWallet.getPubkey();
            domWalletSelector.add(cOption);
          }
          // If we have an unencrypted key, skip the login screen!
          if (cWallet.getPrivkey()) finishLogin();
        } else {
          // No wallet available, check for an unencrypted key
          const tmpwifkey = localStorage.getItem("tmpwifkey");
          let tmppass = localStorage.getItem("tmppass");
          if (!tmppass) throw "Unable to find encwif, and no tmppass available, bailing out!";
          console.log("Unable to find encrypted keys, but tmppass is available, checking for imported wifkey...");
          if (tmpwifkey) {
            console.log("Encrypting import key...");
            // Save decrypted copy in memory, immediately erase from disk
            cWallet.setKeys(null, tmpwifkey);
            // This looks strange, but it's happening for pointer-safety reasons, trust me
            cWallet = WALLET.addWallet(cWallet);
            localStorage.removeItem("tmpwifkey");
            // Encrypt wallet and save it to disk
            encryptWallet(tmppass).then(newEncwif => {
              console.log("Encrypted wallet!");
              // Erase the tmppass from disk and memory
              tmppass = null;
              localStorage.removeItem("tmppass");
              // Load the new keys
              const strPubkey = WALLET.sccjs.wallet.pubFromPriv(WALLET.getActiveWallet().getPrivkey());
              cWallet.setKeys(strPubkey, null, newEncwif);
              DB.setWallet(WALLET.toDB());
              // Load the Dashboard screen
              domLoginPage.style.display = "none";
              switchToDashboard();
              // Give the cache a kick
              setTimeout(() => {
                getBalance(true);
              }, 750);
            });
          } else {
            console.log("Deriving new key...");
            WALLET.createWallet().then(objWallet => {
              // Save decrypted copy in memory
              cWallet.setKeys(objWallet.pubkey, objWallet.privkey);
              // Encrypt wallet and save it to disk
              encryptWallet(tmppass).then(newEncwif => {
                console.log("Encrypted wallet!");
                cWallet.setKeys(null, null, newEncwif);
                DB.setWallet(WALLET.toDB());
                // Erase the tmppass from disk and memory
                tmppass = null;
                localStorage.removeItem("tmppass");
                // Load the Dashboard screen
                domLoginPage.style.display = "none";
                switchToDashboard();
              });
            });
          }
        }
      });
    }

    cElectron.ipcRenderer.on('cmd', (event, message) => {
      // Only process messages matching protocol specs
      if (!message.includes('=')) return;
      const [strCMD, strContent] = message.split('=');
      if (strCMD.length <= 1 || strContent.length <= 1) return;

      // Log the request details
      console.log('--- New URI Request ---');
      console.log('Command: ' + strCMD);
      console.log('Content: ' + strContent);

      try {
        // Find any compatible commands
        if (strCMD === 'sign') {
          // Content should be in HEX and will be converted to utf8
          const strConverted = Buffer.from(strContent, 'hex').toString('utf8');
          // (If not logged in) Switch the default after-login screen
          if (!fDecrypted)
            funcStarter = switchToSigs;
          else
            switchToSigs();
          // Switch the signer mode
          domSigSelector.selectedIndex = 0;
          changeSigType(domSigSelector);
          // Enter the input
          domSigMessageInput.value = strConverted;
          // Focus on the Sign button
          domSigConfirmBtn.focus();
        } else {
          console.warn('URI command is unrecognised, cannot continue processing!');
        }
      } catch(e) {
        M.toast({html: 'Website sent a malformed URI request!<br>Debug logs are available to view.', displayLength: 5000});
        console.warn('Something went wrong with the request, perhaps malformed content?');
        console.warn(e);
      }

      console.log('--- End URI Request ---');
    })

    function showTooltip(obj) {
      obj = document.getElementById(obj);
      obj.style.opacity = "1";
      obj.style["z-index"] = "1000";
    }

    function hideTooltip(obj) {
      obj = document.getElementById(obj);
      obj.style.opacity = "0";
      obj.style["z-index"] = "-1000";
    }
  </script>

  <main class="main-body">
    <div class="container marketing pt-navbar" id="dashboardPage">

      <h4 class="mb-5 theme-color-secondary font-weight-bold">Dashboard</h4>

      <div class="row">
        <div class="col-md-7">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Balance<span
                  id="balanceRefresh" onclick="getBlockCount(); getUnspentTransactions();" class="float-end theme-color refresh-button reload hover-darker"><i class="fas fa-redo-alt"></i></span></div>
              <div class="mt-4 theme-color-secondary font-weight-bold">
                <div class="float-end"><span id="guiBalance" class="font-balance">...</span> <span
                    class="font-size-ticker">SCC</span></div><br><br>
                <div class="float-end balance-usd-props"><span
                    id="balanceUSD" class="font-balance-usd font-gray font-weight-normal">...</span> <span
                    class="font-size-ticker-usd font-gray font-weight-normal">USD</span></div>
              </div>
            </div>
          </div>

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Activity</div>
              <span id="domActivitySCC" onclick="setActivityView(false);" style="cursor: pointer; opacity: 0.4;" class="badge badge-theme">SCC</span>
              <span id="domActivitySCP" onclick="setActivityView(true);" style="cursor: default;" class="badge badge-theme">SCP</span>
              <div id="activityList" style="overflow-y: auto; max-height: 320px; padding-right: 10px;">
                <center style='margin-top:30px;'><p>You have no activity!</p></center>
              </div>
            </div>
          </div>

        </div>
        <div class="col-md-5">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Overview</div>
              <div class="mt-4 theme-color-secondary font-weight-bold font-size-overview">
                <span class="font-gray">Price:</span>
                <span class="float-end" id="dashboardPrice">Loading...</span><br>
                <span class="font-gray">Marketcap:</span>
                <span class="float-end" id="dashboardMarketcap">Loading...</span><br>
                <span class="font-gray">Current Block:</span>
                <span class="float-end" id="dashboardBlock">Loading...</span>
              </div>
            </div>
          </div>

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold" style="margin-bottom:10px;">SCP Tokens</div>
              <span id="domClaimAllBtn" onclick="claimAll();" style="display: none; cursor: pointer;" class="badge badge-theme">Claim All</span>
              <div id="dashboardTokens" style="overflow-y: auto; max-height: 200px; padding-right: 10px; margin-top: 10px;">
                <center><p>Loading SCP</p></center>
              </div>
            </div>
          </div>
        </div>
      </div>


    </div>

    <div class="container marketing pt-navbar" id="sendPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Send</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Transfer coins or tokens</div>

              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> &nbsp;Please make sure to enter the correct address. Transactions cannot be reversed.</div><br>

              <div class="row">
                <div class="col-sm-12">
                  <select id="sendingCoin" class="vodiapicker">
                    <option value="" data-thumbnail="imgs/i.png" disabled selected hidden>-</option>
                    <option value="scc" data-thumbnail="imgs/circular-logo.svg">StakeCubeCoin (SCC)</option>
                  </select>
                  <p>Select Token:</p>
                  <div class="lang-select">
                    <button id="sendingCoinVal" class="btn-select" value="scc"></button>
                    <div class="b" style="z-index:1000;">
                      <ul id="a"></ul>
                    </div>
                  </div>
                </div>
              </div><br>

              <div class="row">
                <div class="col-md-6" style="margin: 20px 0;">
                  <div class="omrs-input-group" style="width:100%; margin-bottom: 0px;">
                    <label class="omrs-input-underlined">
                      <input required id="sendAmount" type="text">
                      <span class="omrs-input-label">Amount</span>
                    </label>
                  </div>
                  <span style="font-size: 13px; top:5px; position: relative;">Available: <span id="sendingCoinBalance" onclick="autofillSendingAmount()" style="cursor: pointer;" class="badge badge-theme" style="margin-bottom:0px">-</label></span>
                </div>

                <div class="col-md-6" style="margin: 20px 0;">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required id="sendAddress" type="text">
                      <span class="omrs-input-label">Recipient Address</span>
                    </label>
                  </div>
                </div>

                <div class="col text-end"><br>
                  <button class="btn btn-layout btn-theme" id="sendTx" onclick="sendTransactionGUI()">Send Transaction</button><br>
                </div>

                <script>
                  $("#sendTx").on("keydown", function(e){
                    if(e.keyCode === 13){
                      if (!allowEnterKey) e.preventDefault();
                    }
                  });
                </script>
              </div>
            </div>
          </div>

        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="receivePage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Receive</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Receive address</div>
              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> Please make sure to only send SCC or SCP tokens to this address. Other coins will be lost and cannot be reversed.</div><br>
              
              <center>
                <div onclick="copyToClipboard(WALLET.getActiveWallet().getPubkey(), 'Address')" class="refresh-button hover-darker">
                  <span id="receiveAddress" class="font-weight-bold"></span>
                  <span style="padding-left:6px;">
                    <i class="far fa-copy"></i>
                  </span>
                </div>
              </center>
              <br>
              <center><img id="receiveQR" style="width: 25%;height:auto;image-rendering:pixelated;"></center>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="sigPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Sign or Verify</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Sign or Verify a message</div>

              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> &nbsp;If you sign a message, please ensure you understand the contents of it, do not sign messages that you would not agree to.</div><br>

              <div class="row">
                <div class="col-sm-12">
                  <select id="sigType" class="form-select" oninput="changeSigType(this)">
                    <option selected value="sign">Mode: Sign a message</option>
                    <option value="verify">Mode: Verify a message</option>
                  </select>
                </div>
              </div><br>

              <div class="row">
                <div class="col-md-6" style="width: 100%;">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required="" id="signerMessage" type="text">
                      <span class="omrs-input-label">Message</span>
                    </label>
                  </div>
                  <div class="omrs-input-group" id="signerAddressBar" style="width:100%; display: none;">
                    <label class="omrs-input-underlined">
                      <input required="" id="signerAddress" type="text">
                      <span class="omrs-input-label">Signer Address</span>
                    </label>
                  </div>
                  <div class="omrs-input-group" id="signerSignatureBar" style="width:100%; display: none;">
                    <label class="omrs-input-underlined">
                      <input required="" id="signerSignature" type="text">
                      <span class="omrs-input-label">Message Signature</span>
                    </label>
                  </div>
                  <div style="text-align: center;">
                    <p>Signature Output</p>
                    <textarea disabled="" id="signerOutput" style="width: 100%;height: auto;margin-top: 0px;margin-bottom: 0px;background-color: transparent;color: #888888;"></textarea>
                  </div>
                </div>
              </div>

              <div class="row">
                <div class="col text-end">
                  <br>
                  <button class="btn btn-layout btn-theme" id="signBtn" onclick="runSignerGUI()">Sign Message</button><br>
                </div>
              </div>

              <script>
                function runSignerGUI(str  = domSigMessageInput.value,
                                      addr = domSigAddress.value,
                                      sig  = domSigSignature.value) {
                  if (strSigType === 'sign') {
                    WALLET.sccjs.signer.sign(str, WALLET.getActiveWallet().getPrivkey()).then(buf => {
                      domSigOutput.value = buf.toString('base64');
                      copyToClipboard(buf.toString('base64'), 'Signature');
                    });
                  } else if (strSigType === 'verify') {
                    try {
                      const valid = WALLET.sccjs.signer.verify(str, addr, sig);
                      domSigOutput.value = valid ? 'Signature is valid! :)' : 'Signature is invalid! :(';
                    } catch(e) {
                      domSigOutput.value = e.message;
                    }
                  }
                }

                let strSigType = 'sign';
                function changeSigType(obj) {
                  // Reset inputs
                  domSigOutput.value = '';
                  domSigMessageInput.value = '';
                  domSigAddress.value = '';
                  // Display relevent UI
                  strSigType = obj.options[obj.selectedIndex].value;
                  if (strSigType === 'sign') {
                    domSigConfirmBtn.innerText = 'Sign Message';
                    domSigAddressBar.style.display = 'none';
                    domSigSignatureBar.style.display = 'none';
                  } else {
                    domSigConfirmBtn.innerText = 'Verify Message';
                    domSigAddressBar.style.display = 'block';
                    domSigSignatureBar.style.display = 'block';
                  }
                }

                $("#signBtn").on("keydown", e => {
                  if (e.keyCode === 13 && !allowEnterKey) e.preventDefault();
                });
              </script>
            </div>
          </div>

        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="authPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">StakeCube 2FA</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div id="authTitle" class="card-title font-gray font-weight-bold">Setup your 2FA</div>
                <div class="alert alert-danger-custom" style="font-size:13px;">
                  <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i>Do <b>not</b> share these codes with <b>anyone!</b>
                </div>
                <div class="alert alert-warning-custom" style="font-size:13px;">
                  <i class="fas fa-info-circle" style="margin-right: 6px;"></i> The 2FA screen can be used as an in-wallet 2FA app for your StakeCube.net account, if you haven't already setup 2FA on your StakeCube.net account, use this and secure your account with your wallet!<br><br>
                  To find your 2FA settings, login to StakeCube.net, visit your settings, and copy your 2FA "Secret", below the QR code, into the "Secret Code" section of this 2FA screen, then you're secured!
                </div><br>
                <div id="authImport">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required id="authSecretImport" type="text" autofocus>
                      <span class="omrs-input-label">2FA</span>
                    </label>
                  </div>
                  
                  <center><button onclick="import2FA()" style="margin-top: 10px;" class="btn btn-theme btn-layout">Import</button></center>
                  <br>
                </div>
                <center id="authDisplay">
                  <div onclick="copyToClipboard(document.getElementById('authCode').innerText, '2FA code')" class="refresh-button hover-darker">
                    <span id="authCode" style="font-size: x-large;" class="font-weight-bold"></span>
                    <i  style="padding-left:6px;" class="far fa-copy refresh-button"></i>
                  </div>
                  <p id="authTime" style="opacity: 0.8;">10 seconds left til next code</p>
                  <br>
                </center>
              <center id="authReset"><button onclick="remove2FA()" style="margin-top: 10px;" class="btn btn-danger btn-layout">Remove 2FA</button></center>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="stakingPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">SCP-2 Staking</h4>

      <center>
        <h3>Est. APR of <b id="stakingApy">---</b></h3>
      </center>
      <br>
      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold" id="stakingTitle">Loading...</div>
              <br>
              <center>
                <p id="stakingSubtitle">Loading...</p>
                <h2 id="stakingRewards">...</h2>
                <p id="stakingRoi" style="opacity:0.5;"></p>
                <br>
                <button id="stakingRedeem" class="btn btn-layout btn-theme disabled" onclick="redeemTokens()">Claim Rewards</button>
              </center><br><br>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container marketing pt-navbar" id="settingsPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Settings</h4>


      <div class="card card-prop mb-4">
        <div class="card-body">

          <div class="accordion" id="accordionExample">
            <div class="accordion-item">
              <h2 class="accordion-header" id="headingOne">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                  <span class="darkText">Personalization</span>
                </button>
              </h2>
              <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
                <div class="accordion-body">

                  <div class="row">
                    <div class="col-9">
                      <span>Allow 'Enter' key to continue actions</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will mean hitting 'Enter' will not perform or continue any actions or dialogs.<br>This setting is ignored on all Password fields.</span>
                    </div>
                    <div class="col-3">
                      <div>
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="allowEnterKeySetting" checked="true" setting="allowEnterKey" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Display the 2FA menu</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will hide the 2FA button from the header menu.<br>This will not remove or lose any 2FA codes, only hide them visually.</span>
                    </div>
                    <div class="col-3">
                      <div>
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="display2FAMenuSetting" checked="true" setting="display2FAMenu" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Minimise to Tray</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will revert back to Taskbar-based minimisation.</span>
                    </div>
                    <div class="col-3">
                      <div>
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="minToTraySetting" checked="true" setting="minToTray" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Limit Activity to 200 TXs</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will let the Activity display unlimited TXs, however this may cause performance issues on large wallets.</span>
                    </div>
                    <div class="col-3">
                      <div>
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="limitActivitySetting" checked="true" setting="limitActivity" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Hide Empty Wallets</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will display empty (0-balance) wallets in their respective area.</span>
                    </div>
                    <div class="col-3">
                      <div>
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="hideZeroBalanceSetting" checked="true" setting="hideZeroBalance" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  
                </div>
              </div>
            </div>
            <div class="accordion-item">
              <h2 class="accordion-header" id="headingTwo">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="true" aria-controls="collapseTwo">
                  <span class="darkText">Wallet</span>
                </button>
              </h2>
              <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
                <div class="accordion-body">

                  <div class="row">
                    <div class="col-9">
                      <span>Switch Account</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Switch into a different wallet account from your multi-wallet.</span>
                    </div>
                    <div class="col-3">
                      <select id="walletSelector" class="form-select form-select-sm" aria-label=".form-select-sm example">
                        <option selected disabled>Select Account</option>
                      </select>
                    </div>
                  </div>
                  
                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-sm-9">
                      <span>Create additional Account</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Creates another account in your multi-wallet. (Note: New accounts are NOT yet encrypted!)
                      </span>
                    </div>
                    <div class="col-sm-3">
                      <div style="padding: 10px 0;">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <button class="btn btn-primary" onclick="createAdditionalAccount()" style="width: 100%; min-width: 80px;">Create</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-sm-9">
                      <span>Export Wallet</span><br>
                      <span style="font-size:12px; color:#97a1b1;">You can use this private file to move your wallet to another device, or as a backup.</span>
                    </div>
                    <div class="col-sm-3">
                      <div style="padding: 10px 0;">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <button class="btn btn-primary" onclick="showFileInExplorer(DB.appdata.getAppDataPath(path.join('SCPWallet', 'wallet.json')))" style="width: 100%; min-width: 80px;">Export</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                </div>
              </div>
            </div>
            <div class="accordion-item">
              <h2 class="accordion-header" id="headingThree">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="true" aria-controls="collapseThree">
                  <span class="darkText">Developer</span>
                </button>
              </h2>
              <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                  <!--  TODO: allow API key setting once a new upload solution is in place
                  <div class="row">
                    <div class="col-6">
                      <span>nft.storage API key</span><br>
                      <span style="font-size:12px; color:#97a1b1;">The API key will be used for IPFS upload on <a href="https://nft.storage" target="_blank">nft.storage</a></span>
                    </div>
                    <div class="col-1">
                      <button id="saveApiKey" class="btn btn-layout btn-theme" onclick="setAPI(this, document.getElementById('ipfsApiKeySetting'))">Save</button>
                    </div>
                    <div class="col-5">
                      <div class="omrs-input-group" style="width:100%; margin-bottom: 0px;">
                        <label class="omrs-input-underlined">
                          <input id="ipfsApiKeySetting" type="password" setting="ipfsApiKey" >
                          <span class="omrs-input-label">API Key</span>
                        </label>
                      </div>
                    </div>
                    
                  </div>
                  
                  <hr style="color: #bcc4d2;">
                -->
                  <div class="row">
                    <div class="col-9">
                      <span>Display the SCP Developer menu</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Enabling this will display the SCP Developer Toolkit menu.<br>This page can be used for creating, deploying and interacting with custom DApps!</span>
                    </div>
                    <div class="col-3">
                      <div>
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="displayDevMenuSetting" checked="false" setting="displayDevMenu" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <div class="container marketing pt-navbar" id="createTokenPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Create Token</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Token information</div>

              <script>
               
                
                let nDeploymentVer = 0;
                function changeTokenType(obj) {
                  domScpTokenDeployArea.style.display = 'block';
                  document.getElementById('scpTokenSettings').style.display = '';
                  const strDesc = document.getElementById('scpTokenDescription');
                  nDeploymentVer = Number(obj.options[obj.selectedIndex].value);
                  if (obj.options[obj.selectedIndex].value == '1') {
                    document.getElementById('scp2TokenSettings').style.display = 'none';
                    document.getElementById('scp2TokenSettings2').style.display = 'none';
                    document.getElementById('scp4TokenSettings').style.display = 'none';
                    strDesc.innerText = 'SCP-1 is a minimalistic issuer-minted token, featuring on-demand issuer minting, burns from anyone, and a max supply cap for barebones security.';
                  } else if (obj.options[obj.selectedIndex].value == '2') {
                    strDesc.innerText = 'SCP-2 is an advanced SCP-1 variant, with trustworthy issuance based on fair and fractional PoS, incentivising users to hold for long periods.';
                    document.getElementById('scp2TokenSettings').style.display = 'flex';
                    document.getElementById('scp2TokenSettings2').style.display = 'flex';
                    document.getElementById('scp4TokenSettings').style.display = 'none';
                  } else if (obj.options[obj.selectedIndex].value == '4') {
                    strDesc.innerText = 'SCP-4 is an NFT Standard which allows deploying "Collections" with NFT max-mints, burn protection and IPFS image enforcement.';
                    document.getElementById('scpTokenSettings').style.display = 'none';
                    document.getElementById('scp2TokenSettings').style.display = 'none';
                    document.getElementById('scp2TokenSettings2').style.display = 'none';
                    document.getElementById('scp4TokenSettings').style.display = 'flex';
                  }

                  // Force a re-check of the params
                  checkDeployerInput();
                }

                // Write an 'oninput' function that checks all inputs, logs errors in the below warning div, and disables button until good
                function checkDeployerInput() {
                    // Reset the warning error
                    domScpTokenErrors.innerHTML = "";
                    let isComplete = true;

                    // SCP-1 CHECKS
                    if (nDeploymentVer === 1 || nDeploymentVer === 2) {
                      // Name
                      if (domScpTokenName.value.length > 1) {
                          // Swap spaces for artificial whitespace unicodes
                          domScpTokenName.value = domScpTokenName.value.replace(/ /g, ' ');
                          // Limit to 25 characters
                          if (domScpTokenName.value.length > 25) domScpTokenName.value = domScpTokenName.value.substr(0, 25);
                      } else {
                          isComplete = false;
                      }

                      // Ticker
                      if (domScpTokenTicker.value.length > 1) {
                          // Remove all whitespace
                          domScpTokenTicker.value = domScpTokenTicker.value.replace(/ /g, '').trim();
                          // Limit to 6 characters
                          if (domScpTokenTicker.value.length > 6) domScpTokenTicker.value = domScpTokenTicker.value.substr(0, 6);
                      } else {
                          isComplete = false;
                      }

                      // Supply
                      if (domScpTokenSupply.value.length) {
                          // Remove all whitespace
                          domScpTokenSupply.value = domScpTokenSupply.value.replace(/ /g, '').trim();
                          const nSupply = Math.round(Number(domScpTokenSupply.value.trim()) * COIN);
                          // Supply must be 1 coin minimum
                          if (nSupply < COIN) {
                              domScpTokenErrors.innerHTML += 'Supply: Minimum is 1!<br>';
                              isComplete = false;
                          }
                          // Do not allow supplies larger than the safe integer
                          if (!Number.isSafeInteger(nSupply)) {
                              domScpTokenErrors.innerHTML += 'Supply: Max supply is ' + (Math.floor((Number.MAX_SAFE_INTEGER / COIN) / 1000000)).toLocaleString('en-GB', { maximumFractionDigits: 0 }) + 'm!<br>';
                              isComplete = false;
                          }
                      } else {
                          isComplete = false;
                      }
                    }
                    
                    // SCP-2 CHECKS
                    if (nDeploymentVer === 2) {
                        // Block Reward
                        if (domScpTokenPoSReward.value.length) {
                            // Remove all whitespace
                            domScpTokenPoSReward.value = domScpTokenPoSReward.value.replace(/ /g, '').trim();
                            const nReward = Math.round(Number(domScpTokenPoSReward.value.trim()) * COIN);
                            // Reward must be a number
                            if (!Number.isFinite(nReward)) {
                                domScpTokenErrors.innerHTML += 'Rewards: Must be a number!<br>';
                                isComplete = false;
                            }
                            // Reward cannot be smaller than 0.0001 coins
                            if (nReward < Math.round(0.001 * COIN)) {
                                domScpTokenErrors.innerHTML += 'Rewards: Cannot be smaller than 0.0001!<br>';
                                isComplete = false;
                            }
                            const nSupply = Math.round(Number(domScpTokenSupply.value.trim()) * COIN);
                            // Reward cannot be equal to the max supply
                            if (nReward === nSupply) {
                                domScpTokenErrors.innerHTML += 'Rewards: Cannot be equal to the max supply!<br>';
                                isComplete = false;
                            }
                            // Reward cannot be larger than to the max supply
                            if (nReward > nSupply) {
                                domScpTokenErrors.innerHTML += 'Rewards: Cannot be larger than the max supply!<br>';
                                isComplete = false;
                            }
                        } else {
                            isComplete = false;
                        }

                        // Min Stake Age
                        if (domScpTokenMinAge.value.length) {
                            // Remove all whitespace
                            domScpTokenMinAge.value = domScpTokenMinAge.value.replace(/ /g, '').trim();
                            const nMinAge = Number(domScpTokenMinAge.value);
                            // Min Age must be an integer
                            if (!Number.isInteger(nMinAge)) {
                                domScpTokenErrors.innerHTML += 'Min Age: Must be an integer!<br>';
                                isComplete = false;
                            }
                            // Min Age must be atleast 1 block
                            if (nMinAge <= 1) {
                                domScpTokenErrors.innerHTML += 'Min Age: Must be atleast 2 blocks!<br>';
                                isComplete = false;
                            }
                            // Min Age must be a safe integer
                            if (Number.isInteger(nMinAge) && !Number.isSafeInteger(nMinAge)) {
                                domScpTokenErrors.innerHTML += 'Min Age: Too large to be safe!<br>';
                                isComplete = false;
                            }
                        } else {
                            isComplete = false;
                        }
                    }

                    // SCP-4 CHECKS
                    if (nDeploymentVer === 4) {
                        // Name
                        if (domScpCollectionName.value.length > 1) {
                            // Swap spaces for artificial whitespace unicodes
                            domScpCollectionName.value = domScpCollectionName.value.replace(/ /g, ' ');
                            // Limit to 40 characters
                            if (domScpCollectionName.value.length > 40) domScpCollectionName.value = domScpCollectionName.value.substr(0, 40);
                        } else {
                            isComplete = false;
                        }

                        // Max Mints
                        if (domScpCollectionMaxMints.value.length) {
                            // Remove all whitespace
                            domScpCollectionMaxMints.value = domScpCollectionMaxMints.value.replace(/ /g, '').trim();
                            const nMaxMints = Number(domScpCollectionMaxMints.value);
                            // Max Mints must be an integer
                            if (!Number.isInteger(nMaxMints)) {
                                domScpTokenErrors.innerHTML += 'Max Mints: Must be an integer!<br>';
                                isComplete = false;
                            }
                            // Max Mints must be larger than 0, or -1 for unlimited
                            if (nMaxMints < 1 && nMaxMints !== -1) {
                                domScpTokenErrors.innerHTML += 'Max Mints: Must be atleast 1 mint! (Or -1 for unlimited)<br>';
                                isComplete = false;
                            }
                            // Max Mints must be a safe integer
                            if (Number.isInteger(nMaxMints) && !Number.isSafeInteger(nMaxMints)) {
                                domScpTokenErrors.innerHTML += 'Max Mints: Too large to be safe!<br>';
                                isComplete = false;
                            }
                        } else {
                            isComplete = false;
                        }
                    }

                    // Apply any error messages, if they exist
                    if (domScpTokenErrors.innerHTML.length) {
                        document.getElementById('scpTokenErrorsWidget').style.display = '';
                        domScpTokenDeployBtn.setAttribute('disabled', '');
                    } else {
                        document.getElementById('scpTokenErrorsWidget').style.display = 'none';
                        if (isComplete)
                          domScpTokenDeployBtn.removeAttribute('disabled');
                    }

                    // Disable the button if the form isn't complete
                    if (!isComplete) {
                        domScpTokenDeployBtn.setAttribute('disabled', '');
                    }
                }

                function guiDeploySCP() {
                    // Cannot deploy if the button is disabled (due to unsatisfied inputs)
                    if (domScpTokenDeployBtn.hasAttribute('disabled')) return;
                    // Convert the input into SCP params
                    const arrParams = [];

                    // SCP-1 Spec
                    if (nDeploymentVer === 1) {
                        // Name
                        arrParams.push(domScpTokenName.value);
                        // Ticker
                        arrParams.push(domScpTokenTicker.value);
                        // Supply
                        arrParams.push((Number(domScpTokenSupply.value.trim()) * COIN).toString());
                    }

                    // SCP-2 Spec
                    if (nDeploymentVer === 2) {
                        // Name
                        arrParams.push(domScpTokenName.value);
                        // Ticker
                        arrParams.push(domScpTokenTicker.value);
                        // Supply
                        arrParams.push(Math.round(Number(domScpTokenSupply.value.trim()) * COIN).toString());
                        // PoS Reward
                        arrParams.push(Math.round(Number(domScpTokenPoSReward.value.trim()) * COIN).toString());
                        // Min Stake Age
                        arrParams.push(domScpTokenMinAge.value);
                    }

                    // SCP-4 Spec
                    if (nDeploymentVer === 4) {
                        // Collection Name
                        arrParams.push(domScpCollectionName.value);
                        // Max Mints
                        arrParams.push(domScpCollectionMaxMints.value);
                        // Protected
                        arrParams.push(domScpCollectionProtected.checked ? '1' : '0');
                    }

                    if (arrParams.length > 1)
                        deploySCP(nDeploymentVer, arrParams);
                }
                
              </script>

              <div class="alert alert-danger-custom" style="font-size:13px; display: none;" id="scpTokenErrorsWidget">
                <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i><b id="scpTokenErrors"></b>
              </div>

              <select id="scpDeploySelector" class="form-select" oninput="changeTokenType(this)" style="margin-bottom: 20px;">
                <option selected disabled>Token type</option>
                <option value="1">SCP-1</option>
                <option value="2">SCP-2</option>
                <option value="4">SCP-4</option> 
              </select>

              <div class="col-md-12">
                <div style="width:100%;">
                    <p id='scpTokenDescription' style="text-align: center;">
                      Select a token standard to get started!
                    </p>
                </div>
              </div>
              
              <hr style="color: #bcc4d2;">

              <div id="scpTokenSettings" style="display: none;">
                <div class="row">
                  <div class="col-md-6">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpTokenName" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Token Name</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('tokenNameTip')"
                        onmouseout="hideTooltip('tokenNameTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="tokenNameTip" style="z-index: -1000;">The public name of your token, displayed on SCP Wallet, Explorers, etc.</span>
                      </label>
                    </div>
                  </div>

                  <div class="col-md-6">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpTokenTicker" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Token Ticker</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('tokenTickerTip')"
                        onmouseout="hideTooltip('tokenTickerTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="tokenTickerTip" style="z-index: -1000;">The public ticker of your token, displayed on SCP Wallet, Explorers, etc.</span>
                      </label>
                    </div>
                  </div>
                </div>

                <div class="row">
                  <div class="col-md-6">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpTokenSupply" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Max Supply</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('maxSupplyTip')"
                        onmouseout="hideTooltip('maxSupplyTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="maxSupplyTip" style="z-index: -1000;">The maximum amount of tokens that can exist at once.</span>
                      </label>
                    </div>
                  </div>

                  <div class="col-md-6">
                    <div id="scp2TokenSettings" style="display:none;">
                      <div class="omrs-input-group" style="width:100%;">
                        <label class="omrs-input-underlined">
                          <input id="scpTokenPoSReward" oninput="checkDeployerInput()" required type="text">
                          <span class="omrs-input-label">Block Reward</span>
                          <span class="omrs-input-hover" onmouseover="showTooltip('blockRewardTip')"
                          onmouseout="hideTooltip('blockRewardTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                        <span class="omrs-input-message" id="blockRewardTip" style="z-index: -1000;">The reward per-block in tokens, distributed in proportional fractions to stakeholders.</span>
                        </label>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="row" style="display:none;" id="scp2TokenSettings2">
                  <div class="col-md-6">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpTokenMinAge" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Minimum Staking Age</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('stakingAgeTip')"
                          onmouseout="hideTooltip('stakingAgeTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                        <span class="omrs-input-message" id="stakingAgeTip" style="z-index: -1000;">The minimum time, in blocks, that tokens must stay untouched before earning staking rewards.</span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>

              <div id="scp4TokenSettings" style="display: none;">
                <div class="row">
                  <div class="col-md-8">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpCollectionName" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Collection Name</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('collectionNameTip')"
                        onmouseout="hideTooltip('collectionNameTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="collectionNameTip" style="z-index: -1000;">The public name of your NFT Collection, displayed on SCP Wallet, SC Marketplace, Explorers, etc.</span>
                      </label>
                    </div>
                  </div>

                  <div class="col-md">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpCollectionMaxMints" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Max Mints</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('collectionMaxMintsTip')"
                        onmouseout="hideTooltip('collectionMaxMintsTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="collectionMaxMintsTip" style="z-index: -1000;">Maximum NFT mints allowed.<br><br>Use -1 for unlimited minting.</span>
                      </label>
                    </div>
                  </div>

                  <div class="row" style="margin-bottom: 1em;">
                    <div class="col" style="text-align: center;padding-right: 0px;">
                      <span>Protected</span>
                      <div class="form-check form-switch" style="width: 100%;display: flex;padding-left: 4px;margin-top: 5px;">
                        <input class="form-check-input darkBorder" type="checkbox" value="" id="scpCollectionProtected" checked="true" style="margin-left: auto;margin-right: auto;">
                      </div>
                      <span style="font-size:12px;color:#97a1b1;">Disabling this will allow NFTs in this Collection to be burned by its holders.</span>
                    </div>
                  </div>
                  <hr style="color: #bcc4d2;">
                </div>
              </div>

              <center id="scpTokenDeployArea" style="display: none;">
                <button id="scpTokenDeployBtn" onclick="guiDeploySCP()" disabled style="margin-top: 10px;" class="btn btn-theme btn-layout">Create token</button>
                <p style="margin-top: 20px;opacity: 0.35;">Deploying an SCP Token requires a fixed deployment fee of 10 SCC!</p>
              </center>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-fluid marketing pt-navbar" id="viewCollection">
      <div class="container-fluid" style="margin-top: 10px;">

        <h4 class="mb-5 theme-color-secondary font-weight-bold" id="collectionName">My NFTs</h4>

        <div class="float-end" style="margin-top:-50px;">
          <button type="button" id="scpNftMintBtn" class="btn btn-theme btn-sm" style="margin-right:0.5em;" onclick="switchToNftCreator()" disabled>Mint NFT</button>
          <button type="button" class="btn btn-theme btn-sm" onclick="switchToCollections()">Explore All Collections</button>
        </div>

        <div id="nftSearch" class="omrs-input-group" style="min-width: 50%;margin-left: auto;margin-right: auto;max-width: 100%;">
          <label class="omrs-input-underlined">
            <input class="darkerInput" oninput="renderNFTs(nSelectedCollection, this.value.replace(/ /g, ' ').toLowerCase())" required="" type="text">
            <span class="omrs-input-label">Search (name, contract or creator)</span>
            <span class="omrs-input-hover"><i class="fas fa-search tooltip-questionmark"></i></span>
          </label>
        </div>

        <div class="row d-flex justify-content-center" id="nftList"></div>
      </div>
    </div>



    <div class="container-fluid marketing pt-navbar" id="NFTCollections">
      <div class="container">
        <h4 class="mb-5 theme-color-secondary font-weight-bold">NFT Collections</h4>

        <div class="float-end" style="margin-top:-50px;">
          <button type="button" class="btn btn-theme btn-sm" style="margin-right:0.5em;" onclick="switchToCreateToken('4')">Create Collection</button>
          <button type="button" class="btn btn-theme btn-sm" onclick="switchToViewCollection();renderNFTs(-1);">My NFTs</button>
        </div>

        <div class="omrs-input-group" style="min-width: 50%;margin-left: auto;margin-right: auto;max-width: 100%;">
          <label class="omrs-input-underlined">
            <input class="darkerInput" id="collectionSearch" oninput="renderCollections(this.value.replace(/ /g, ' ').toLowerCase())" required="" type="text">
            <span class="omrs-input-label">Search (name, contract or creator)</span>
            <span class="omrs-input-hover"><i class="fas fa-search tooltip-questionmark"></i></span>
          </label>
        </div>

        <div class="card card-prop mb-4">
          <div class="card-body">
            <div class="card-title font-gray font-weight-bold">Collections</div>
            <table class="table table-hover">
              <thead>
                <tr>
                  <th scope="col">Name</th>
                  <th scope="col">Supply</th>
                  <th scope="col">Max Mints</th>
                  <th scope="col">Protected</th>
                  <th scope="col">Actions</th>
                </tr>
              </thead>

              <tbody id="collectionsList">
                <tr>
                  <td>Loading...</td>
                  <td>...</td>
                  <td>...</td>
                  <td><span class="subtext">...</span></td>
                  <td style="padding-top: 11px;">...</td>
                </tr>
              </tbody>
            </table>

          </div>    
        </div>


      </div>
    </div>



    <div class="container-fluid marketing pt-navbar" id="viewNFT">
      <div class="container">
        <div class="d-inline-flex flex-column lh-sm" style="position: relative; top: -7px">
          <span id="nftDetailTitle" class="hover-darker" onclick="copyToClipboard(this.innerText, 'Name')" style="font-size:x-large;cursor:pointer;"></span>
          <span id="nftDetailMintCount" style="font-size:0.75em;background-color: transparent;" class="kbd">
            <b></b><b style="opacity: 0.75"></b>
          </span>
        </div>
        <div class="float-end">
          <button type="button" id="nftDetailCollection" class="btn btn-theme btn-sm" onclick="switchToViewCollection();renderNFTs();" style="margin-right:1em;">Visit Collection</button>
          <button type="button" class="btn btn-theme btn-sm" onclick="switchToViewCollection();renderNFTs();">Back</button>
        </div>

        <div class="row">
          <div class="col-4">
            <img id="nftDetailImg" class="hover-darker" onclick="copyToClipboard(this.src, 'Image URL')" style="width:100%;border-radius: 10px;cursor:pointer;">
            <div id="nftDetailActions" class="card card-prop mt-4">
              <div class="card-body" style="padding-top: 9px;">
                <div class="card-title font-gray font-weight-bold">Actions</div>
                <div class="row">
                  <div class="col-6" style="padding-right: 3px;">
                    <button type="button" id="nftTransferBtn" class="btn btn-theme btn-sm w-100" data-bs-toggle="modal" data-bs-target="#sendNftModal">Transfer</button>
                  </div>
                  <div class="col-6" style="padding-left: 3px;">
                    <button type="button" id="nftBurnBtn" class="btn btn-theme btn-sm w-100" style="background-color:#e08080;" data-bs-toggle="modal" data-bs-target="#burnNftModal">Burn</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col-8">
            <div class="card card-prop mb-4">
              <div class="card-body">
                <div class="card-title font-gray font-weight-bold">Details</div>

                <div style="font-size:12px;">
                  <div class="row">
                    <div class="col">
                      <span class="ls-1">ID</span>
                      <code id="nftDetailID" onclick="copyToClipboard(this.innerText, 'NFT ID')" style="cursor:pointer" class="kbd hover-darker"></code>
                    </div>
                  </div><br>

                  <span class="ls-1">IPFS CID</span>
                  <span id="nftDetailImageID" onclick="copyToClipboard(this.innerText, 'IPFS CID')" style="cursor:pointer" class="kbd hover-darker"></span><br><br>

                  <span class="ls-1">OWNER ADDRESS</span>
                  <code id="nftDetailOwner" onclick="copyToClipboard(this.innerText, 'Address')" style="cursor:pointer" class="kbd hover-darker"></code>
                  
                  <div id="nftMarketDetails" style="display: none;">
                    <hr>
                    <p style="width: max-content;margin: auto;">
                      <b style="font-size: 15px;">Last Price:</b> <span id="nftMarketLast">1 SCC ($1)</span>
                      <br>
                      <b style="font-size: 15px;">All-time-high:</b> <span id="nftMarketHigh">1 SCC ($1)</span>
                      <br>
                      <b style="font-size: 15px;">All-time-low:</b> <span id="nftMarketLow">1 SCC ($1)</span>
                    </p>
                  </div>
                </div>
              </div>
            </div>

            <div class="card card-prop mb-4">
              <div class="card-body">
                <div class="card-title font-gray font-weight-bold">Activity</div>

                <table class="table table-hover" style="font-size:13px;">
                  <thead>
                    <tr>
                      <th scope="col">TX</th>
                      <th scope="col">Type</th>
                      <th scope="col">From</th>
                      <th scope="col">To</th>
                      <th scope="col">Block</th>
                    </tr>
                  </thead>
                  <tbody id="nftDetailActivity"></tbody>
                </table>

              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
    <script>
      function switchToNftCreator() {
        const cColl = isFullnode ? NFT.getCollection(nSelectedCollection) : getCachedCollection(nSelectedCollection);
        closeAllTabs();
        domCreateNftPage.style.display = 'block';
        domNftMintSubtitle.innerText = cColl.collectionName + ': Mint an NFT';
      }

      let bRawImageBuf;
      async function uploadImageDialog() {
        const ret = await dialog.showOpenDialog({
          'title': 'Select an Image for your NFT',
          'filters': [
            { name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'gif'] }
          ],
          'properties': [
            'openFile',
            'treatPackageAsDirectory'
          ]
        });
 
        if (ret === undefined || ret.canceled || !ret.filePaths.length) return false;
        // Load file into buffer
        bRawImageBuf = DB.fs.readFileSync(ret.filePaths[0]);
        // Update UI
        const domPreview = document.getElementById('nftPreviewImg');
        // Figure out what filetype we're working with, for rendering purposes
        const dotSplit = ret.filePaths[0].split('.');
        const fileType = dotSplit[dotSplit.length - 1].toLowerCase();
        // Encode buffer as native base64, remove any formatting lines, inject into renderer
        domPreview.style['background-image'] = 'url(data:image/' + fileType + ';base64,' + bRawImageBuf.toString('base64').replace(/(\r\n|\n|\r)/gm, '') + ')';
        domPreview.style['background-repeat'] = 'no-repeat';
        domPreview.style['background-position'] = 'center';
        checkNftInput();
        return await bRawImageBuf;
      }
      let lastImageHash = '0'.repeat(64);
      //let nLastImageLen = 0;
      let strLastImageCID = '';
      async function nftUpload() {
        // Cannot deploy if the button is disabled (due to unsatisfied inputs)
        if (document.getElementById('scpNftDeployBtn').hasAttribute('disabled')) return;
        const intervals = Number(document.getElementById('scpNftDeployQty').value);
        domNftMintOpts.style.display = 'none';
        domNftMintProgress.style.display = 'block';
        const cText = document.getElementById('mintText');
        cText.innerText = 'Warming Up';
        await sleep(500);
        const cProgress = document.getElementById('mintProgress');
        cProgress.style.width = '10%';
        await sleep(1000);
        try {
          const hash = Array.from(
            new Uint8Array(await crypto.subtle.digest('SHA-256', bRawImageBuf))
          ).map(b => b.toString(16).padStart(2, '0')).join('');
          //console.log(`${lastImageHash} === ${hash}`)
          const fAlreadyUploaded = lastImageHash === hash;
          //const fAlreadyUploaded = bRawImageBuf.length === nLastImageLen;
          cProgress.style.width = (fAlreadyUploaded ? '50' : '20') + '%';
          cText.innerText = fAlreadyUploaded ? 'Fetching cached IPFS CID' : 'Uploading image to IPFS';
          if(!!!ipfsAPI) throw new Error("No IPFS API key in settings.");
          const cRetIPFS = !fAlreadyUploaded ? JSON.parse(await NET.uploadToIPFS(ipfsAPI, bRawImageBuf)) : undefined;
          try {
            for (let i = 0; i<intervals; i++) {
              const fLastMint = i === intervals - 1;
              if ((fAlreadyUploaded && strLastImageCID) || (cRetIPFS && cRetIPFS.ok && cRetIPFS.value.cid.length)) {
                // Prepare the progress text
                const strInterval = !fLastMint ? ' (' + (i+1) + '/' + intervals + ')' : '';
                // Fetch the latest UTXOs
                cProgress.style.width = '70%';
                cText.innerText = 'Preparing UTXOs' + strInterval;
                const strAddr = WALLET.getActiveWallet().getPubkey();
                await WALLET.refreshUTXOs(strAddr);
                // Construct mint transaction
                const strName = document.getElementById('scpNftName').value;
                cProgress.style.width = '80%';
                cText.innerText = 'Minting "' + formatName(strName, 24) + '"' + strInterval;
                console.log('NFT Uploader: ' + (fAlreadyUploaded ?
                                              'Using cached CID' :
                                              'Uploaded new image (' + bRawImageBuf.length + 'b) to IPFS'));
                // Save the image byte length (this will be used to prevent re-uploads of the same image)
                lastImageHash = Array.from(
                  new Uint8Array(await crypto.subtle.digest('SHA-256', bRawImageBuf))
                ).map(b => b.toString(16).padStart(2, '0')).join('');
                //console.log(`lastImageHash: ${lastImageHash}`)
                //nLastImageLen = bRawImageBuf.length;
                // Grab the IPFS CID
                const strCID = fAlreadyUploaded ? strLastImageCID : cRetIPFS.value.cid;
                strLastImageCID = strCID;
                // Prepare wallet
                const cCollection = isFullnode ? NFT.getCollection(nSelectedCollection) : getCachedCollection(nSelectedCollection);
                console.log("Constructing SCP-" + cCollection.version + " NFT mint TX!");
                // Contruct SCP transaction
                const cTx = WALLET.sccjs.wallet.tx.transaction();
                // Add input
                const cUTXO = WALLET.getCoinsToSpend(2000, true, strAddr)[0];
                if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
                cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
                // SCP output
                cTx.addoutputburn(0.00000001, cCollection.contract + ' mint ' + strName + ' ' + strCID);
                // Fee & Change output
                const nFee = WALLET.getFee(cTx.serialize().length);
                const nChange = cUTXO.sats - nFee;
                cTx.addoutput(strAddr, nChange / COIN);
                // Sign
                cText.innerText = 'Signing TX' + strInterval;
                const strSignedTx = await cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1);
                cProgress.style.width = '90%';
                // Broadcast
                cText.innerText = 'Broadcasting TX' + strInterval;
                const strTXID = await WALLET.broadcastTx(strSignedTx);
                cUTXO.spent = true;
                if (fLastMint) {
                  strLastNftID = strTXID;
                  M.toast({html: 'Minting! Please wait for block confirmations!', displayLength: 5000});
                  cProgress.style.width = '100%';
                  cText.innerText = 'Done!';
                  if (isFullnodePtr()) {
                    getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
                  } else {
                    NET.getMempoolActivityLight(strAddr).then(strRes => {
                      cachedActivityIS = JSON.parse(strRes);
                    });
                    getUnspentTransactions();
                    // Updates NFTs and other contracts
                    getMempoolActivity(strAddr);
                  }
                  setTimeout(() => {
                    cProgress.style.width = '0%';
                    domNftMintOpts.style.display = 'block';
                    domNftMintProgress.style.display = 'none';
                  }, 2500);
                }
              } else {
                cProgress.style.width = '0%';
                domNftMintOpts.style.display = 'block';
                domNftMintProgress.style.display = 'none';
                return M.toast({html: 'IPFS Upload failed, retry later!', displayLength: 3000});
              }
            }
          } catch (e) {
            console.error('NFT Broadcast error: Likely a wallet or UTXO set issue, please wait for one block before re-attempting!');
            console.error(e);
            M.toast({html: 'Mint error! Please re-try in one block, wallet may be exhausted.', displayLength: 5000});
            cProgress.style.width = '100%';
            cText.innerText = 'Broadcast Failure!';
            setTimeout(() => {
              cProgress.style.width = '0%';
              domNftMintOpts.style.display = 'block';
              domNftMintProgress.style.display = 'none';
            }, 2500);
          }
        } catch (e) {
          console.log(e);
          cProgress.style.width = '0%';
          domNftMintOpts.style.display = 'block';
          domNftMintProgress.style.display = 'none';
          return M.toast({html: 'Failed to reach IPFS Node, retry later!', displayLength: 3000});
        }
      }

      function checkNftInput() {
        let isComplete = true;

        // Name
        const nftName = document.getElementById('scpNftName');
        if (nftName.value) {
          // Swap spaces for artificial whitespace unicodes
          nftName.value = nftName.value.replace(/ /g, ' ');
          // Limit to 25 characters
          if (nftName.value.length > 25) nftName.value = nftName.value.substr(0, 25);
        } else {
          isComplete = false;
        }
        // Set the sanitised display name
        document.getElementById('nftCreatorName').innerText = nftName.value;

        // Image
        if (!bRawImageBuf || !bRawImageBuf.length) {
          isComplete = false;
        }

        if (isComplete) {
          document.getElementById('scpNftDeployBtn').removeAttribute('disabled');
        } else {
          document.getElementById('scpNftDeployBtn').setAttribute('disabled', '');
        }
      }

      function clearNftCreator() {
        document.getElementById('nftPreviewImg').style['background-image'] = '';
        bRawImageBuf = null;
        document.getElementById('scpNftName').value = '';
        checkNftInput();
        document.getElementById('nftCreatorName').innerText = 'Click to edit image';
      }
    </script>

    <div class="container marketing pt-navbar" id="createNftPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Mint NFT</h4>
      
      <div class="float-end" style="margin-top:-50px;">
        <button type="button" class="btn btn-theme btn-sm" onclick="switchToViewCollection()">Visit Collection</button>
      </div>
    
      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div id="nftMintSubtitle" class="card-title font-gray font-weight-bold">NFT information</div>

              <div class="alert alert-danger-custom" style="font-size:13px; display: none;" id="scpTokenErrorsWidget">
                <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i><b id="scpTokenErrors"></b>
              </div>

              <hr style="color: #bcc4d2;">

              <div class="row">
                <div class="col-md">
                  <div class="omrs-input-group" style="width: 50%;margin-left: auto;margin-right: auto;min-width: 250px;">
                    <label class="omrs-input-underlined">
                      <input id="scpNftName" oninput="checkNftInput()" required type="text">
                      <span class="omrs-input-label">Name</span>
                      <span class="omrs-input-hover" onmouseover="showTooltip('nftNameTip')"
                        onmouseout="hideTooltip('nftNameTip')"><i
                          class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="nftNameTip" style="z-index: -1000;">The public name of your
                        NFT, displayed on SCP Wallet, Explorers, etc.</span>
                    </label>
                  </div>
                </div>
              </div>
              <div class="row">
                <div class="col-md">
                  <div class="col-3" style="width: 100%;">
                    <div class="card card-prop nftCard" id="nftPreviewImg" onclick="uploadImageDialog()" style="background-color: #08429838 !important;height: 250px;margin-left: auto;margin-right: auto;width: 175px;">
                      <div class="card-body refresh-button">
                        <span id="nftCreatorName" class="badge nftname">Click to edit image</span>
                      </div>
                    </div>
                  </div>
                  <p onclick="clearNftCreator()" style="text-align: center;margin: 5 0 0 0;opacity: 0.4;cursor: pointer;">Clear</p>
                </div>
              </div>
              <center id="nftMintOpts">
                <br>
                <h5>
                  Quantity of NFT Mints
                  <input id="scpNftDeployQty" type="range" class="form-range" value="1" min="1" max="20" id="nftQuantity">
                </h5>
                <p style="opacity:0.3;font-size:0.7em;margin-top:1rem;margin-bottom: 0;">Minting NFTs is FREE! There are no additional costs for minting, minus blockchain fees.</p>
                <button id="scpNftDeployBtn" onclick="nftUpload()" disabled="" style="margin-top: 10px;" class="btn btn-theme btn-layout">Start Minting</button>
              </center>
              <center id="nftMintProgress" style="display: none;">
                <h5 id="mintText" style="margin-bottom: 0.5em; margin-top: 0.5em;">Initializing Minter</h5>
                <div class="progress" style="border-color:#0d6efd;border-style:solid;border-width:1px;">
                  <div id="mintProgress" class="progress-bar" role="progressbar" style="width: 0%;background: linear-gradient(90deg, rgba(3, 23, 52, 0.97), #0a58ca 100%);" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
              </center>
              </div>
            </div>
          </div>
        </div>
      </div>
    

    <script>
      let cSelectedNFT;
      function sendNftGUI() {
        const strTo = document.getElementById('sendAddressNft').value.trim();
        // Verify the address
        if (!strTo || strTo.length !== 34 || !strTo.startsWith("s")) {
          return M.toast({html: 'Please enter a valid address!', displayLength: 2000});
        }
        // Prepare wallet data
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const strPrivkey = WALLET.getActiveWallet().getPrivkey();
        // Construct the transaction
        const cTx = WALLET.sccjs.wallet.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(2000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        const fIndexed = UPGRADES.isTokenIndexingActive(isFullnode ? nCacheHeight : cachedBlockCount);
        const idContract = fIndexed ? 'id' + cSelectedNFT.collectionIndex : cSelectedNFT.collection;
        cTx.addoutputburn(0.00000001, idContract + ' transfer ' + strTo + ' ' + cSelectedNFT.nft);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = cUTXO.sats - nFee;
        cTx.addoutput(strAddr, nChange / COIN);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            M.toast({html: 'NFT Sent!', displayLength: 3000});
            cUTXO.spent = true;
            getUnspentTransactions();
            // Move user back to their NFTs page
            switchToViewCollection();
            renderNFTs();
          });
        });
      }

      function burnNftGUI() {
        // Prepare wallet data
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const strPrivkey = WALLET.getActiveWallet().getPrivkey();
        // Construct the transaction
        const cTx = WALLET.sccjs.wallet.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(2000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        const fIndexed = UPGRADES.isTokenIndexingActive(isFullnode ? nCacheHeight : cachedBlockCount);
        const idContract = fIndexed ? 'id' + cSelectedNFT.collectionIndex : cSelectedNFT.collection;
        cTx.addoutputburn(0.00000001, idContract + ' destroy ' + cSelectedNFT.nft);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = cUTXO.sats - nFee;
        cTx.addoutput(strAddr, nChange / COIN);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            M.toast({html: 'NFT Burned!', displayLength: 3000});
            cUTXO.spent = true;
            getUnspentTransactions();
            // Move user back to their NFTs page
            switchToViewCollection();
            renderNFTs();
          });
        });
      }

      const setAPI = async (el1, el2) =>{
        el1.disabled = true;
        el2.disabled = true;
        try {
          if(!!el2.value){
            const resp = JSON.parse(await NET.testIPFS(el2.value));             
          }         
          setValueSetting(el2);          
          M.toast({html: 'Saved API key!', displayLength: 2000});
        } catch (e) {
          console.log(e)
          M.toast({html: 'Invalid nft.storage API key!', displayLength: 2000});
        }
        el1.disabled = false;
        el2.disabled = false;
      }
    </script>

    <div class="modal fade" id="sendNftModal" tabindex="-1" aria-labelledby="sendNftModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="sendNftModalLabel">Send your NFT</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="col-md" style="margin: 20px 0;">
              <div class="omrs-input-group" style="width:100%;">
                <label class="omrs-input-underlined">
                  <input required id="sendAddressNft" style="text-align: center;" type="text">
                  <span class="omrs-input-label">Recipient Address</span>
                </label>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" data-bs-dismiss="modal" onclick="sendNftGUI()">Send</button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal fade" id="burnNftModal" tabindex="-1" aria-labelledby="burnNftModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="burnNftModalLabel">Burn your NFT</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="col-md" style="margin: 20px 0;text-align: center;">
              <h5 style="font-weight: bold; ">Are you sure you want to burn your NFT?</h5>
              <p>This action is irreversible! </p>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-danger" data-bs-dismiss="modal" onclick="burnNftGUI()">Burn</button>
          </div>
        </div>
      </div>
    </div>



    <i id="themeButton" onclick="loadNextTheme();" class="fas fa-sun" style="position: fixed; bottom: 10px; left: 10px; color: black; opacity: 0.5; cursor: pointer;"></i>
  </main>

  <!-- Materialize Library -->
  <script type="text/javascript" src="js/materialize.js"></script>
  <script src="js/bootstrap.bundle.min.js"></script>
  <script src="js/select.js"></script>

</body>

</html>
