<html class="main-html" lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SCP Wallet</title>

  <link rel="canonical" href="https://getbootstrap.com/docs/5.0/examples/carousel/">

  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
  <link id="themeSheet" themeIndex="0" href="style/latest-style-light.css" rel="stylesheet">
  <link href="fontawesome/css/fontawesome.min.css" rel="stylesheet">
  <link href="fontawesome/css/all.min.css" rel="stylesheet">
  
  <!-- Functional Libraries (Cryptography, Hashing, Encryption, Encoding, etc) -->
  <script type="text/javascript" src="../scripts/aes-gcm.js"></script>

  <!-- Interface Framework Libraries (GUI, wallet management, networking, etc) -->
  <script type="text/javascript" src="../scripts/qrcode.js"></script>
  <script type="text/javascript" src="../scripts/settings.js"></script>
  <script type="text/javascript" src="../scripts/wallet.js"></script>
  <script type="text/javascript" src="../scripts/network.js"></script>
  <script type="text/javascript" src="js/switchPages.js"></script>

  <!-- SCP LIBRARY GOES BELOW -->
  <script type="text/javascript" src="../src/index.js"></script>
  <!-- SCP LIBRARY GOES ABOVE -->

  <script>window.$ = window.jQuery = require('jquery');</script>
</head>

<body>
  <div id="loginPage" class="page-gradient" style="display: block;">
    <div class="container marketing">
      <div class="verticalalign" style="padding-top: 5%;">
        <div class="vertical-center color-white">
          <center>
            <img src="imgs/logo.svg" style="height:50px;">
            <i id="versionLogin" style="position: static;color: white;opacity: 0.6;font-size: small;cursor: default;letter-spacing: 1px;"></i>
            <br><br>
          </center>
          <div class="container">
            <div class="row align-items-center" style="height: 50%;">
              <div class="col-sm-10 offset-sm-1">
                <div class="login-card card-prop2 mb-4">
                  <div class="card-body font-gray">
                    <div class="login-page">
                      <center>
                        <h5 class="mb-3">Unlock your wallet</h5>
                        <br>
                        <div class="omrs-input-group" style="width:100%; margin-bottom:10px;">
                          <label style="display: flex;" class="omrs-input-underlined">
                            <input required id="pass1" type="password" autofocus>
                            <span class="omrs-input-label">Password</span>
                            <button onclick="switchLoginVisibility()" style="background-color: transparent;border-style: none;outline: none;">
                              <i id="pass1Visibility" class="fas fa-eye-slash"></i>
                            </button>
                          </label>
                        </div>
                      </center>

                      <script>
                        'use strict';
                        function switchLoginVisibility() {
                          if (domPass1Visibility.classList.contains("fa-eye-slash")) {
                            // Display pass
                            domPass1Visibility.classList.remove("fa-eye-slash");
                            domPass1Visibility.classList.add("fa-eye");
                            document.getElementById("pass1").setAttribute("type", "text");
                          } else {
                            // Hide pass
                            domPass1Visibility.classList.remove("fa-eye");
                            domPass1Visibility.classList.add("fa-eye-slash");
                            document.getElementById("pass1").setAttribute("type", "password");
                          }
                        }

                        $(document).ready(function(){
                          $('#pass1').keypress(function(e){
                            if(e.keyCode==13) {
                              finishLogin();
                            }
                          });
                        });
                      </script>

                      <table class="mb-0" border="0">
                        <tr class="info">
                          <td>
                            <i class="fas fa-info-circle" style="margin-right: 10px;"></i>
                          </td>
                          <td>
                            Please remember to write down your password, if you lose it, StakeCube cannot recover your funds!
                          </td>
                        </tr>
                      </table>

                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    function finishLogin() {
      let nPass = document.getElementById("pass1").value;
      decryptWallet(nPass).then(done => {
        if (done) {
          document.getElementById("pass1").value = "";
          switchToDashboard();
          DB.setWallet(WALLET.toDB()).then(() => {
            if (localStorage.getItem("encwif")) {
              localStorage.removeItem("encwif");
              console.log("DB: Migrated 'encwif' from LS to Backend DB!");
            }
          });
          // Give the cache a kick
          setTimeout(() => {
            getBalance(true);
          }, 750);
          // If an update is available, notify the user after a brief period
          if (isOutdated) {
            setTimeout(() => {
              M.toast({html: '<a style="cursor: pointer;" onclick="openExternalURL(\'https://github.com/stakecube/StakeCubeProtocol/releases/latest\')">An update is available!</a>', displayLength: 30000});
            }, 3 * 1000);
          }
          console.log("Login successful!");
        } else {
          M.toast({html: 'Incorrect Password!', displayLength: 2000});
        }
      });
    }
  </script>

  <header id="guiHeader" style="display: none;">
    <nav class="navbar navbar-expand-md navbar-dark fixed-top navbar-colour font-weight-bold">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">
          <img onclick="switchToDashboard()" src="imgs/logo.svg" height="30">
          <i id="version" style="position: relative;color: white;opacity: 0.4;font-size: x-small;cursor: default;letter-spacing: 1px;bottom: -1px;"></i>
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
          aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarCollapse">
          <ul class="navbar-nav me-auto mb-2 mb-md-0">
            <li class="nav-item">
              <a class="nav-link active" id="dashboardBtn" aria-current="page" href="#" onclick="switchToDashboard()">
                <i class="fas fa-tachometer-alt" style="margin-right: 5px;"></i>
                Dashboard
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="sendBtn" onclick="switchToSend()">
                <i class="fas fa-paper-plane" style="margin-right: 5px;"></i>
                Send
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="receiveBtn" onclick="switchToReceive()">
                <i class="fas fa-money-check" style="margin-right: 5px;"></i>
                Receive
              </a>
            </li>
            <li class="nav-item" id="2faBtnMenu">
              <a class="nav-link" href="#" id="2faBtn" onclick="switchToAuth()">
                <i class="fas fa-fingerprint" style="margin-right: 5px;"></i>
                2FA
              </a>
            </li>
          </ul>
          <form class="d-flex" style="margin-bottom:0px;">
            <a href="#" onclick="switchToSettings()"><i class="fas fa-cog fas-higher-contrast"></i></a>
          </form>
        </div>
      </div>
    </nav>
  </header>

  <script>
    'use strict';
    // GUI module imports
    const { clipboard } = require('electron');
    let authenticator = require("otplib").authenticator;

    // WALLET STATE DATA
    let cachedTokens = [];
    let cachedBlockCount = 0;
    let cachedActivity = [];
    let cachedActivityIS = [];
    let cachedCoinDeltas = [];

    // Statistical / Informational data
    let valueUSD = 0;
    let currentSupply = 0;

    // Cached DOM elements
    let activityViewSCP = true;
    let domHeader;
    let domLoginPage;
    let domDashboardBtn;
    let domSendBtn;
    let domReceiveBtn;
    let dom2FABtn;
    let dom2FAMenu;
    let domDashboardPage;
    let domSendPage;
    let domReceivePage;
    let domAuthPage;
    let domStakingPage;
    let domSettingsPage;

    let domPass1Visibility;

    let domReceiveAddress;
    let domBalance;
    let domBalanceUSD;
    let domSendingBalance;
    let domActivityList;
    let domActivitySCC;
    let domActivitySCP;
    let domClaimAllBtn;

    let domMarketcap;
    let domPrice;
    let domBlock;

    let domAuthDisplay;
    let domAuthImport;
    let domAuthTitle;
    let domAuthCode;
    let domAuthTime;
    let domAuthReset;

    let domStakingTitle;
    let domStakingSubtitle;
    let domStakingApy;
    let domStakingRewards;
    let domStakingRedeem;
    let domStakingRoi;

    function getMempoolDeltas(strCurrency) {
      let nDelta = 0;
      if (strCurrency === 'scc') {
        // TODO: Add SCC InstantSend mempool-deltas
      } else {
        const cToken = TOKENS.getToken(strCurrency);
        if (!cToken.error) {
          for (const cActivity of cachedActivityIS) {
            if (cActivity.token.contract !== cToken.contract) continue;
            if (cActivity.type === 'received' || cActivity.type === 'staked') {
              nDelta += cActivity.amount;
            } else if (cActivity.type === 'sent') {
              nDelta -= cActivity.amount;
            }
          }
        }
      }
      return nDelta;
    }

    function hasMempoolStakes(contract) {
      let fStaked = false;
      const cToken = TOKENS.getToken(contract);
      if (!cToken.error) {
        for (const cActivity of cachedActivityIS) {
          if (cActivity.token.contract !== cToken.contract) continue;
          if (cActivity.type === 'staked') {
            fStaked = true;
          }
        }
      }
      return fStaked;
    }

    function addMockActivity(strType = "unknown", nAmount = 0, cToken) {
      let cActivity = {
          'id': null,
          'token': {
              'contract': cToken.contract,
              'ticker': cToken.ticker,
              'name': cToken.name
          },
          'block': 'Unconfirmed',
          'contract': cToken.contract,
          'account': WALLET.getActiveWallet().getPubkey(),
          'type': strType,
          'amount': nAmount,
      }
      cachedActivityIS.push(cActivity);
    }

    function updateMempoolActivity(arrNewActivity) {
      cachedActivityIS = cachedActivityIS.concat(arrNewActivity).filter(function(item, pos) {
        return cachedActivityIS.indexOf(item) == pos;
      });
    }

    async function getMempoolActivity(account = false) {
      const arrFullMempool = await getFullMempool();
      const arrActivity = [];
      // Loop all mempool TXs
      for (const cTX of arrFullMempool) {
          // Loop all TX vouts
          for (const cVout of cTX.vout) {
              if (!cVout.scriptPubKey) continue;
              if (!cVout.scriptPubKey.hex) continue;
              // Scan the scriptPubKey for OP_RETURN (+ PUSHDATA)
              if (cVout.scriptPubKey.hex.startsWith('6a4c')) {
                  // Found an OP_RETURN! Parse the message from HEX to UTF-8
                  const rawHex = cVout.scriptPubKey.asm.substr(10);
                  const buf = Buffer.from(rawHex, 'hex');
                  const strOp = buf.toString('utf8');
                  if (!strOp.includes(' ')) continue;
                  const arrOp = strOp.split(' ');
                  const isLongData = strOp.length > 64;
                  let isUsingIndex = false;
                  if (UPGRADES.isTokenIndexingActive(nCacheHeight)) {
                      isUsingIndex = strOp.startsWith('id');
                      arrOp[0] = Number(arrOp[0].substr(2));
                  }
                  // If one of these flags are enabled, this is highly likely a normal token event
                  if (isLongData || isUsingIndex) {
                      // Ensure the token is valid and exists
                      const cToken = TOKENS.getToken(arrOp[0]);
                      if (!cToken || cToken.supply <= 0) continue;
                      // Construct the caller's Activity object
                      const cActivity = {
                          'id': cTX.txid,
                          'token': {
                              'contract': cToken.contract,
                              'ticker': cToken.ticker,
                              'name': cToken.name
                          },
                          'block': (cTX.instantlock ? '⚡ ' : '') + 'Unconfirmed',
                          'contract': cToken.contract,
                          'account': cTX.vout[1].scriptPubKey.addresses[0],
                          'type': 'unknown',
                          'amount': 0
                      };
                      const cAccount = cActivity.account;
                      // Identify the transaction type
                      const operation = arrOp[1];
                      switch (operation) {
                      case 'mint':
                          cActivity.type = 'received';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      case 'burn':
                          cActivity.type = 'sent';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      case 'send':
                          // Sender activity
                          cActivity.type = 'sent';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          // Receiver activity
                          const cRecvActivity = JSON.parse(
                              JSON.stringify(cActivity));
                          cRecvActivity.type = 'received';
                          cRecvActivity.account = arrOp[3];
                          if (!account ||
                                  (account && arrOp[3] === account)) {
                              arrActivity.push(cRecvActivity);
                          }
                          break;

                      case 'redeem':
                          cActivity.type = 'staked';
                          const cStatus = cToken.getStakingStatus(cAccount);
                          cActivity.amount = cStatus.unclaimed_rewards;
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      default:
                          break;
                      }
                      // End the vout loop
                      break;
                  }
              }
          }
      }
      return arrActivity;
    }

    function getSyncPercentage() {
      // We measure based on our total SCP hash-cache, and our blocks since the start of SCP
      if (cachedBlockCount === 0 || chainHashesCache.length === 0) return 0;
      if (!currentScanBlock || !currentScanBlock.height) return 100;
      return percentOf(nCacheScannedBlks, (cachedBlockCount - nFirstBlock));
    }

    function getBalance(updateGUI = false) {
      let nBalance = WALLET.getBalance();

      // Update the GUI too, if chosen
      if (updateGUI) {
        // --- Update SCC Balances
        // Set the balance, and adjust font-size for large balance strings
        domBalance.innerHTML = nBalance.toLocaleString('en-GB', { maximumFractionDigits: 8 });
        if (valueUSD > 0)
          domBalanceUSD.innerText = (nBalance * valueUSD).toFixed(2);
        // And update the Receive page pubkey
        let strPubkey = WALLET.getActiveWallet().getPubkey();
        domReceiveAddress.innerText = strPubkey;

        // --- Update SCP token balances
        // Fetch all tokens owned by our account (strPubkey)
        if (isFullnode)
          cachedTokens = TOKENS.getTokensByAccount(strPubkey);
        else
          getTokensByAccountLight(strPubkey);
        // Loop all tokens, construct an updated GUI for the Dashboard
        let dashboardTokens = document.getElementById("dashboardTokens");
        let sendTokensSelector = document.getElementById('sendingCoin');
        sendTokensSelector.innerHTML = '<option value="scc" data-thumbnail="imgs/circular-logo.png">StakeCubeCoin (SCC)</option>';
        dashboardTokens.innerHTML = '';
        if (chainHashesCache.length === 0 && isFullnode) {
          dashboardTokens.innerHTML += '<center style=\'margin-top:30px;\'><p>Loading SCP</p></center>';
        } else if (getSyncPercentage() < 99.99 && isFullnode) {
          dashboardTokens.innerHTML += '<center style=\'margin-top:30px;\'><p id="scpSyncing">SCP is still syncing (' + getSyncPercentage().toFixed(2) + '%)</p></center>';
        } else if (cachedTokens.length > 0) {
          let strDashTokens = "";
          let strSendTokens = "";
          for (const cToken of cachedTokens) {
            let nBal = (getMempoolDeltas(cToken.token.contract) + cToken.account.balance) / COIN;
            if (hideZeroBalance && nBal <= 0) continue;
            let stakingButton = 'onclick="switchToStaking(\'' + cToken.token.contract + '\')"';
            let stakingStyle = 'cursor:pointer;';
            let stakingText = '';
            if (cToken.token.version !== 2) {
              stakingButton = '';
              stakingStyle = '';
            } else {
              let fStaked = hasMempoolStakes(cToken.token.contract);
              if (!fStaked) {
                let nRewards = (cToken.account.unclaimed_balance / COIN);
                // Ensure we have unclaimed stakes, and the token has not hit max supply yet
                if (cToken.account.unclaimed_balance > 0 && (cToken.token.supply + cToken.account.unclaimed_balance) < cToken.token.maxSupply)
                  stakingText = ' <i style="opacity:0.5;">(+' + nRewards.toLocaleString('en-GB', { maximumFractionDigits: (nRewards > 0.1 ? 2 : 8 ) }) + ')</i>';
              } else {
                stakingButton = '';
                stakingStyle = '';
              }
            }
            strDashTokens += '<div class="mt-3 mb-3 font-gray-2 font-weight-bold" style="font-size:15px; max-height: 32px;' + stakingStyle + '" ' + stakingButton + '><img src="imgs/circular-logo.png" style="width:32px; height:32px; margin-right: 10px"><div class="d-inline-flex flex-column lh-sm" style="position: relative; top: -7px"><span>'+ formatName(cToken.token.ticker, 8) +'</span><span style="opacity: 0.75;font-size:0.75em;">SCP-' + cToken.token.version + '</span></div><span class="float-end theme-color-secondary">' + nBal.toLocaleString('en-GB', { maximumFractionDigits: (nBal > 1 ? 2 : 8) }) + stakingText + '</span></div>';
            strSendTokens += '<option value="scptoken-' + cToken.token.contract + '" data-thumbnail="imgs/circular-logo.png">' + formatName(cToken.token.name, 10) + ' (' + cToken.token.ticker + ')</option>';
          }
          dashboardTokens.innerHTML += strDashTokens;
          sendTokensSelector.innerHTML += strSendTokens;
        } else {
          dashboardTokens.innerHTML += '<center style=\'margin-top:30px;\'><p>You have no tokens!</p></center>';
        }

        // Update activity widget
        if (isFullnode) {
          if (getSyncPercentage() >= 99.99) {
            cachedActivity = TOKENS.getActivityByAccount(strPubkey).reverse();
            rpcMain.call('getaddressdeltas', {
              'addresses': [strPubkey]
            }).then(res => {
              cachedCoinDeltas = res.reverse();
            }).catch(e => {
              // Fallback incase this node doesn't support address indexing
              getDeltasByAccountLight(strPubkey);
            });
          }
        } else {
          getActivityByAccountLight(strPubkey);
          getDeltasByAccountLight(strPubkey);
        }
        // Fetch SCC Deltas (a list of changes on this address)
        if (!isFullnode || isFullnode && getSyncPercentage() >= 99.99)
          renderActivity();
      }

      return Number(nBalance.toFixed(8));
    }

    function renderActivity() {
      // Our 'view' is either SCP or SCC, depending on the user's Activity settings
      const arrView = JSON.parse(JSON.stringify(activityViewSCP ? cachedActivity : cachedCoinDeltas));
      let strActivityList = "";
      if (arrView.length > 0) {
        domActivityList.innerHTML = "";
        let arrTxView = [];
        // (SCC view ONLY) Sort the individual output deltas into per-transaction deltas
        if (!activityViewSCP) {
          for (const cDelta of arrView) {
            let fFoundTx = false;
            for (const cTxDelta of arrTxView) {
              // Found a previous TX delta for this output, merge into one
              if (cDelta.txid === cTxDelta.txid) {
                cTxDelta.satoshis += cDelta.satoshis;
                fFoundTx = true;
              }
            }
            // Didn't find any TX deltas, add a new one (Deep Clone)
            if (!fFoundTx) {
              arrTxView.push(JSON.parse(JSON.stringify(cDelta)));
            }
          }
        } else {
          arrTxView = cachedActivityIS.concat(arrView);
        }
        // View SCP or SCC depending on the user's settings
        let i = 0;
        for (const cActivity of arrTxView) {
          if (!activityViewSCP && isScpTx(cActivity.txid)) continue;
          if (limitActivity && i >= 200) break;
          i++;
          const nValue = (cActivity.amount || cActivity.satoshis) / COIN;
          const strTx  = (cActivity.id || cActivity.txid);
          const strBlk = (cActivity.block || cActivity.height).toLocaleString('en-GB');
          const fIsNumBlk = Number.isSafeInteger(cActivity.block || cActivity.height);
          let strType;
          if (activityViewSCP) {
            strType = cActivity.type;
          } else {
            if (cActivity.satoshis >= 0)
              strType = 'received';
            else
              strType = 'sent';
          }
          const strTypeColour = ((strType === 'received' || strType === 'staked') ? "plus" : "minus");
          const strTypeSymbol = ((strType === 'received' || strType === 'staked') ? "+" : "-");
          const strCoinTicker = cActivity.token ? cActivity.token.ticker : 'SCC';
          const strExplorerID = strTx ? 'style="cursor: pointer;" onclick="openExternalURL(\'https://scc.ccore.online/transaction/' + strTx + '\')"' : '';
          strActivityList += '<div class="mt-4" ' + strExplorerID + '><div class="float-start text-center">' + (fIsNumBlk ? 'Block ' : '') + ' ' + strBlk + '</div><span class="float-end ' + strTypeColour + '-balance-color font-weight-bold" style="position:relative; top:11px;"><i style="text-transform: capitalize;padding-right:5px;">' + strType + '</i> ' + strTypeSymbol + Math.abs(nValue).toLocaleString('en-GB', { maximumFractionDigits: nValue > 1 ? 2 : 8, minimumFractionDigits: 2 }) + ' ' + strCoinTicker + '</span></div><br><br><hr style="margin-top:5px; margin-bottom:5px;" class="font-gray">';
        }
        domActivityList.innerHTML += strActivityList;
      } else {
        domActivityList.innerHTML = "<center style='margin-top:30px;'><p>You have no activity!</p></center>";
      }
    }

    function setActivityView(viewSCP) {
      activityViewSCP = viewSCP;
      domActivitySCC.style.opacity = viewSCP ? 0.4 : 1;
      domActivitySCP.style.opacity = viewSCP ? 1 : 0.4;
      domActivitySCC.style.cursor  = viewSCP ? 'pointer' : 'default';
      domActivitySCP.style.cursor  = viewSCP ? 'default' : 'pointer';
      renderActivity();
    }

    function getCachedToken(contract) {
      for (const cToken of cachedTokens) {
        if (cToken.token.contract === contract) return cToken.token;
      }
      return false;
    }

    function getCachedAccount(ctoken, address) {
      for (const cToken of cachedTokens) {
        if (cToken.token.contract === ctoken.contract) return cToken.account;
      }
      return false;
    }

    function isScpTx(strTx) {
      for (const cActivity of cachedActivity) {
        if (cActivity.id === strTx) return true;
      }
      return false;
    }

    function sendTransactionGUI() {
      let coinSelection = document.getElementById("sendingCoinVal").value;
      let sendAmount = Number(document.getElementById("sendAmount").value.trim());
      let sendAddress = document.getElementById("sendAddress").value.trim();
      if (!sendAmount || !Number.isFinite(sendAmount)) {
        return M.toast({html: 'Please enter a valid amount!', displayLength: 2000});
      }
      if (!sendAddress || sendAddress.length !== 34 || !sendAddress.startsWith("s")) {
        return M.toast({html: 'Please enter a valid address!', displayLength: 2000});
      }
      if (coinSelection === "scc") {
        console.log("Constructing TX of value: " + sendAmount + " SCC");
        let cTx = WALLET.sccjs.tx.transaction();
        // Inputs
        let usedUTXOs = WALLET.getCoinsToSpend(sendAmount * COIN, false, WALLET.getActiveWallet().getPubkey());
        let nUTXOs = usedUTXOs.reduce((a, b) => {return a + b.sats}, 0);
        for (const cUTXO of usedUTXOs)
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        if (sendAmount >= nUTXOs / COIN) return M.toast({html: 'Not enough funds!', displayLength: 2000});
        // Destination output
        cTx.addoutput(sendAddress, sendAmount);
        // Fee & Change output
        let nFee = WALLET.getFee(cTx.serialize().length);
        let nSpent = (parseFloat(nFee) + parseFloat(sendAmount)).toFixed(8);
        let nChange = (parseFloat(nUTXOs / COIN) - parseFloat(nSpent)).toFixed(8);
        cTx.addoutput(WALLET.getActiveWallet().getPubkey(), nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          sendTransaction(strSignedTx, usedUTXOs);
        });
      } else {
        let strToken = coinSelection.split('scptoken-')[1];
        let cToken = isFullnode ? TOKENS.getToken(strToken) : getCachedToken(strToken);
        let cAccount = isFullnode ? cToken.getAccount(WALLET.getActiveWallet().getPubkey()) : getCachedAccount(cToken, WALLET.getActiveWallet().getPubkey());
        const nBal = getMempoolDeltas(cToken.contract) + cAccount.balance;
        if ((nBal / COIN) < sendAmount) return M.toast({html: 'You don\'t have enough ' + cToken.ticker + '!', displayLength: 3000});
        console.log("Constructing SCP-" + cToken.version + " Transfer TX for: " + sendAmount + " " + formatName(cToken.name, 12) + " (" + cToken.contract + ")");
        let cTx = WALLET.sccjs.tx.transaction();
        // Add input
        let cUTXO = WALLET.getCoinsToSpend(10000, true, WALLET.getActiveWallet().getPubkey())[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        let fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
        let idContract = fIndexed ? "id" + cToken.index : cToken.contract;
        cTx.addoutputburn(0.00000001, idContract + " send " + (sendAmount * COIN).toFixed(0) + " " + sendAddress);
        // Fee & Change output
        let nFee = WALLET.getFee(cTx.serialize().length);
        let nChange = (parseFloat(cUTXO.sats / COIN) - parseFloat(nFee)).toFixed(8);
        cTx.addoutput(WALLET.getActiveWallet().getPubkey(), nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          addMockActivity("sent", sendAmount * COIN, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            M.toast({html: 'Transaction Sent!', displayLength: 1250});
            if (isFullnodePtr()) {
              getMempoolActivity(WALLET.getActiveWallet().getPubkey()).then(updateMempoolActivity);
            }
          });
        });
      }
    }

    function claimStakingRewards(contract) {
        let cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
        let cAccount = isFullnode ? cToken.getAccount(WALLET.getActiveWallet().getPubkey()) : getCachedAccount(cToken, WALLET.getActiveWallet().getPubkey());
        console.log("Constructing SCP-" + cToken.version + " stake claim TX for " + (cAccount.unclaimed_balance / COIN).toLocaleString('en-GB') + " " + formatName(cToken.name, 12) + " (" + cToken.contract + ")");
        // Disable claim button
        domStakingRedeem.setAttribute('onclick', '');
        domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'Redeeming...';
        // Contruct SCP transaction
        let cTx = WALLET.sccjs.tx.transaction();
        // Add input
        let cUTXO = WALLET.getCoinsToSpend(2000, true, WALLET.getActiveWallet().getPubkey())[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        let fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
        let idContract = fIndexed ? "id" + cToken.index : cToken.contract;
        cTx.addoutputburn(0.00000001, idContract + " redeem");
        // Fee & Change output
        let nFee = WALLET.getFee(cTx.serialize().length);
        let nChange = (parseFloat(cUTXO.sats / COIN) - parseFloat(nFee)).toFixed(8);
        cTx.addoutput(WALLET.getActiveWallet().getPubkey(), nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          addMockActivity("staked", cAccount.unclaimed_balance, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            if (isFullnodePtr()) {
              getMempoolActivity(WALLET.getActiveWallet().getPubkey()).then(updateMempoolActivity);
            }
          });
        });
    }

    let isClaiming = false;
    async function claimAll() {
      if (isClaiming) return console.log("Cancelled sequential claim, a claim is already being performed!");
      isClaiming = true;
      let nClaims = 0;
      const cWallet = WALLET.getActiveWallet();
      for (const cToken of cachedTokens) {
          if (cToken.token.version !== 2) continue;
          if (cToken.account.unclaimed_balance <= 0) continue;
          if (hasMempoolStakes(cToken.token.contract)) continue;
          // Let's claim the rewards!
          domClaimAllBtn.style.opacity = 0.4;
          domClaimAllBtn.style.cursor = "default";
          domClaimAllBtn.innerText = "Claiming " + cToken.token.ticker;
          // Init wallet & TX constructor
          let cTx = WALLET.sccjs.tx.transaction();
          // Asynchronously sync UTXOs with the network
          await WALLET.refreshUTXOs(cWallet.getPubkey());
          // Add input
          let cUTXO = WALLET.getCoinsToSpend(2000, true, cWallet.getPubkey())[0];
          if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
          // SCP output
          let fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
          let idContract = fIndexed ? "id" + cToken.token.index : cToken.token.contract;
          cTx.addoutputburn(0.00000001, idContract + " redeem");
          // Fee & Change output
          let nFee = WALLET.getFee(cTx.serialize().length);
          let nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
          cTx.addoutput(cWallet.getPubkey(), nChange);
          // Sign & Broadcast
          const strSignedTx = await cTx.sign(cWallet.getPrivkey(), 1);
          addMockActivity("staked", cToken.account.unclaimed_balance, cToken.token);
          await WALLET.broadcastTx(strSignedTx);
          nClaims++;
          // Mark UTXO as spent
          cUTXO.spent = true;
          // If no available UTXOs: Sleep to allow the mempool time to return our fresh UTXO set
          if (!WALLET.getAvailableUTXOs(cWallet.getPubkey()).length)
            await sleep(1000);
        }
        await sleep(1000);
        // Refresh the final UTXO set after a small sleep
        await WALLET.refreshUTXOs(cWallet.getPubkey());
        // Reset Claim All button
        domClaimAllBtn.innerText = "Claim All";
        domClaimAllBtn.style.cursor = "pointer";
        domClaimAllBtn.style.display = "none";
        domClaimAllBtn.style.opacity = 1;
        isClaiming = false;
        // Pull mempool transactions
        if (isFullnodePtr()) {
          updateMempoolActivity(await getMempoolActivity(WALLET.getActiveWallet().getPubkey()));
        }
        // Notify the user, finished!
        return M.toast({html: 'Redeemed ' + nClaims + ' rewards!', displayLength: 5000});
    }

    function deploySCP(version = 1, params = []) {
        if (!Number.isSafeInteger(version)) return console.error("SCP token must have a version integer!");
        if (params.length < 3) return console.error("SCP token deployment requires params!\nE.g; deploySCP(1, ['CatCoin', 'CAT', " + COIN + "])");
        // Ensure SCP params look atleast somewhat sane
        for (const param of params) {
          if (typeof param === 'string') {
            if (param.length === 0)  return M.toast({html: 'No empty strings allowed!', displayLength: 3000});
            if (param.length > 24)   return M.toast({html: 'No strings over 24 chars allowed!', displayLength: 4000});
            if (param.includes(' ')) return M.toast({html: 'No spaces allowed in SCP strings!', displayLength: 4000});
          } else
          if (typeof param === 'number') {
            // No floats allowed
            if (!Number.isInteger(param))    return M.toast({html: 'No floats allowed! Please use integers\nRef: ' + param, displayLength: 4000});
            // No integers larger than the safe integer 
            if (!Number.isSafeInteger(param)) return M.toast({html: 'An integer is too large, unsafe to deploy!\nRef: ' + ((param / COIN) / 1000000) + " mil", displayLength: 4000});
          } else {
            return M.toast({html: 'Unsupported param detected: ' + typeof param, displayLength: 3000});
          }
        }
        console.log("Constructing SCP-" + version + " deployment TX");
        let cTx = WALLET.sccjs.tx.transaction();
        // Inputs
        let nDeployCost = (nDeployFee * COIN) + 1000;
        let usedUTXOs = WALLET.getCoinsToSpend(nDeployCost, false, WALLET.getActiveWallet().getPubkey());
        let nUTXOs = usedUTXOs.reduce((a, b) => {return a + b.sats}, 0);
        for (const cUTXO of usedUTXOs)
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        if (nDeployCost >= nUTXOs) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        // SCP output
        cTx.addoutputburn(0.00000001, "SCPCREATE" + version + " " + params.join(" "));
        // Static Deployment fee (Sent to the SCC burn address)
        cTx.addoutput(strDeployFeeDest, nDeployFee);
        // Fee & Change output
        let nFee = WALLET.getFee(cTx.serialize().length);
        let nSpent = (parseFloat(nFee) + parseFloat(nDeployFee)).toFixed(8);
        let nChange = (parseFloat(nUTXOs / COIN) - parseFloat(nSpent)).toFixed(8);
        cTx.addoutput(WALLET.getActiveWallet().getPubkey(), nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          sendTransaction(strSignedTx, usedUTXOs, 'Deploying! Please wait for the contract to confirm in a block!');
        });
    }

    function mintSCP(contract, amount) {
        console.log("Constructing SCP mint TX for " + (amount / COIN).toLocaleString('en-GB'));
        let cTx = WALLET.sccjs.tx.transaction();
        // Add input
        let cUTXO = WALLET.getCoinsToSpend(10000, true, WALLET.getActiveWallet().getPubkey())[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        cTx.addoutputburn(0.00000001, contract + " mint " + amount);
        // Fee & Change output
        let nFee = WALLET.getFee(cTx.serialize().length);
        let nChange = (parseFloat(cUTXO.sats / COIN) - parseFloat(nFee)).toFixed(8);
        cTx.addoutput(WALLET.getActiveWallet().getPubkey(), nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          if (cToken && !cToken.error)
            addMockActivity("received", amount, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
            if (isFullnodePtr()) {
              getMempoolActivity(WALLET.getActiveWallet().getPubkey()).then(updateMempoolActivity);
            }
            M.toast({html: 'Minting ' + (amount / COIN).toLocaleString('en-GB') + ' tokens!', displayLength: 3000});
          });
        });
    }

    function burnSCP(contract, amount) {
        console.log("Constructing SCP burn TX for " + (amount / COIN).toLocaleString('en-GB'));
        // Use our first UTXO, as the fees will be incredibly low anyway
        let cTx = WALLET.sccjs.tx.transaction();
        // Add input
        let cUTXO = WALLET.getCoinsToSpend(10000, true, WALLET.getActiveWallet().getPubkey())[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        cTx.addoutputburn(0.00000001, contract + " burn " + amount);
        // Fee & Change output
        let nFee = WALLET.getFee(cTx.serialize().length);
        let nChange = (parseFloat(cUTXO.sats / COIN) - parseFloat(nFee)).toFixed(8);
        cTx.addoutput(WALLET.getActiveWallet().getPubkey(), nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          if (cToken && !cToken.error)
            addMockActivity("sent", amount, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
            if (isFullnodePtr()) {
              getMempoolActivity(WALLET.getActiveWallet().getPubkey()).then(updateMempoolActivity);
            }
            M.toast({html: 'Burning ' + (amount / COIN).toLocaleString('en-GB') + ' tokens!', displayLength: 3000});
          });
        });
    }

    function autofillSendingAmount() {
      document.getElementById("sendAmount").value = domSendingBalance.innerText.replace(/,/g, '');
    }

    function refreshSendBalance() {
      // Update available balance display
      let strPubkey = WALLET.getActiveWallet().getPubkey();
      let nSendBalanceDisplay = 0;
      let strCurrency = document.getElementById("sendingCoinVal").value;
      if (strCurrency === "scc") {
        nSendBalanceDisplay = getBalance();
      } else {
        let strToken = strCurrency.split('scptoken-')[1];
        let cToken = isFullnode ? TOKENS.getToken(strToken) : getCachedToken(strToken);
        let cAccount = isFullnode ? cToken.getAccount(strPubkey) : getCachedAccount(cToken, strPubkey);
        const nBal = getMempoolDeltas(cToken.contract) + cAccount.balance;
        nSendBalanceDisplay = Number((nBal / COIN).toFixed(8));
      }
      domSendingBalance.innerText = nSendBalanceDisplay.toLocaleString('en-GB', { maximumFractionDigits: 8 });
    }

    function refreshSyncStatus() {
      let domScpSyncing = document.getElementById("scpSyncing");
      let syncPercent = getSyncPercentage();
      if (syncPercent > 99.99) {
        // Sync is close enough to being finished, stop checking and load the tokens!
        clearInterval(syncStatusInterval);
        getBalance(true);
      }
      if (domScpSyncing) {
        domScpSyncing.innerText = 'SCP is still syncing (' + syncPercent.toFixed(2) + '%)';
      } else if (syncPercent > 0) {
        getBalance(true);
      }
    }

    let currentStakingToken = false;
    let guiStakingToken;
    let guiStakingAccount;
    let guiStakingStatus;
    function refreshStakingStatus(contract) {
      let strPubkey = WALLET.getActiveWallet().getPubkey();
      if (isFullnode) {
        guiStakingToken   = TOKENS.getToken(contract);
        guiStakingAccount = guiStakingToken.getAccount(strPubkey);
        guiStakingStatus  = guiStakingToken.getStakingStatus(strPubkey);
      } else {
        guiStakingToken   = getCachedToken(contract);
        guiStakingAccount = getCachedAccount(guiStakingToken, strPubkey);
        getStakingStatusLight(contract, strPubkey);
      }
      // Put token + account info on the Staking Page on this refresh!
      if ((guiStakingToken && guiStakingAccount && guiStakingStatus) && guiStakingStatus.enabled) {
        domStakingTitle.innerText = formatName(guiStakingToken.name, 18) + " (" + formatName(guiStakingToken.ticker, 6) + ")";
        // Run a quick'n'dirty APY calculation based on the current weight reward
        let nReward = guiStakingToken.inflation * guiStakingStatus.weight;
        let nTotalRewards = guiStakingAccount.unclaimed_balance / COIN;
        // Also check to ensure we haven't hit the max supply yet
        if (guiStakingToken.supply === guiStakingToken.maxSupply ||
           (guiStakingToken.supply + guiStakingAccount.unclaimed_balance) >= guiStakingToken.maxSupply)
        {
          domStakingApy.innerText = "0%";
          domStakingRoi.innerText = "";
          domStakingSubtitle.innerText = formatName(guiStakingToken.name, 12) + " has hit it's max supply of " + (guiStakingToken.maxSupply / COIN).toLocaleString('en-GB') + " " + formatName(guiStakingToken.ticker, 6)  + "!";
          domStakingRewards.innerText = "Cap Reached";
          domStakingRedeem.setAttribute('onclick', '');
          if (!domStakingRedeem.classList.contains('disabled'))
            domStakingRedeem.classList.add('disabled');
          domStakingRedeem.innerText = 'No Stakes to Claim';
        } else {
          const fStaked = hasMempoolStakes(guiStakingToken.contract);
          let nAPY = percentOf((nReward * 720) * 365, guiStakingAccount.balance);
          if (nAPY > 0.01 && nReward > 1) {
            domStakingApy.innerText = nAPY.toLocaleString('en-GB', { maximumFractionDigits: (nAPY > 100 ? 0 : 2) }) + "%";
            domStakingRoi.innerText = "or a ROI of " + percentOf(guiStakingAccount.unclaimed_balance, guiStakingAccount.balance).toLocaleString('en-GB', { maximumFractionDigits: 2 }) + "%";
          } else {
            domStakingApy.innerText = "---";
            domStakingRoi.innerText = "";
          }
          domStakingSubtitle.innerHTML = "You've been staking for " + (guiStakingStatus.age - guiStakingToken.minAge).toLocaleString('en-GB') + " blocks and earned...";
          if (fStaked) {
            domStakingRewards.innerText = '0 ' + formatName(guiStakingToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', '');
            if (!domStakingRedeem.classList.contains('disabled'))
              domStakingRedeem.classList.add('disabled');
            domStakingRedeem.innerText = 'No Stakes to Claim';
          } else if (guiStakingAccount.unclaimed_balance > 0) {
            domStakingRewards.innerText = nTotalRewards.toLocaleString('en-GB', { maximumFractionDigits: nTotalRewards > 1 ? 4 : 8}) + " " + formatName(guiStakingToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', 'claimStakingRewards("' + contract + '")');
            domStakingRedeem.classList.remove('disabled');
            domStakingRedeem.innerText = 'Claim Rewards';
          } else {
            domStakingRewards.innerText = '0 ' + formatName(guiStakingToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', '');
            if (!domStakingRedeem.classList.contains('disabled'))
              domStakingRedeem.classList.add('disabled');
            domStakingRedeem.innerText = 'No Stakes to Claim';
          }
        }
      } else if (guiStakingToken && guiStakingAccount && guiStakingStatus) {
        domStakingTitle.innerText = formatName(guiStakingToken.name, 18) + " (" + formatName(guiStakingToken.ticker, 6) + ")";
        domStakingApy.innerText = "---";
        domStakingRoi.innerText = "";
        domStakingSubtitle.innerHTML = "Your tokens need another " + (guiStakingToken.minAge - guiStakingStatus.age).toLocaleString('en-GB') + " blocks to mature before earning stakes!";
        domStakingRewards.innerHTML = nTotalRewards.toLocaleString('en-GB', { maximumFractionDigits: nTotalRewards > 1 ? 4 : 8 }) + " " + guiStakingToken.ticker;
        domStakingRedeem.setAttribute('onclick', '');
        if (!domStakingRedeem.classList.contains('disabled'))
          domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'No Stakes to Claim';
      } else {
        domStakingTitle.innerText = guiStakingToken ? formatName(guiStakingToken.name, 18) + " (" + formatName(guiStakingToken.ticker, 6) + ")" : "Loading...";
        domStakingApy.innerText = "---";
        domStakingRoi.innerText = "";
        domStakingSubtitle.innerHTML = "Loading...";
        domStakingRewards.innerHTML = "...";
        domStakingRedeem.setAttribute('onclick', '');
        if (!domStakingRedeem.classList.contains('disabled'))
          domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'No Stakes to Claim';
      }
    }

    function import2FA() {
      let strNewSecret = document.getElementById("authSecretImport").value;
      let testToken = authenticator.generate(strNewSecret);
      if (testToken && testToken.toString().length === 6) {
        WALLET.set2FAkey(strNewSecret);
        DB.setWallet(WALLET.toDB());
      }
    }

    function remove2FA() {
      WALLET.set2FAkey("");
      DB.setWallet(WALLET.toDB());
      refreshAuthenticator();
    }

    let lastAuthCode = null;
    function refreshAuthenticator() {
      let checkForSecret = localStorage.getItem("authsecret");
      if (checkForSecret) {
        WALLET.set2FAkey(checkForSecret);
        localStorage.removeItem("authsecret");
        console.log("DB: Migrated 2FA LS to Backend DB!");
        DB.setWallet(WALLET.toDB());
      }
      let strSecret = WALLET.get2FAkey();
      if (!strSecret) {
        // No authentication linked
        domAuthImport.style.display = "";
        domAuthDisplay.style.display = "none";
        domAuthTitle.innerText = "Setup your 2FA";
        domAuthReset.style.display = "none";
      } else {
        // Auth code already imported
        domAuthImport.style.display = "none";
        domAuthDisplay.style.display = "";
        domAuthTitle.innerText = "Login using 2FA";
        domAuthReset.style.display = "";
        // Fetch the current code
        let authCode = authenticator.generate(strSecret);
        if (lastAuthCode !== authCode)
          domAuthCode.innerText = authCode;
        let authTimeRemaining = authenticator.timeRemaining()
        domAuthTime.innerText = authTimeRemaining + " second" + (authTimeRemaining === 1 ? "" : "s") + " remaining until next code";
        lastAuthCode = authCode;
      }

      // Also use this chance to update the Staking page, if it's open
      if (domStakingPage.style.display === "block" && currentStakingToken) {
        refreshStakingStatus(currentStakingToken);
      }

      // Also use this to update the Claim All button's visibility
      if (cachedTokens.length && getSyncPercentage() >= 99.99) {
        let nPendingStakes = 0;
        for (const cToken of cachedTokens) {
          if (cToken.token.version !== 2) continue;
          if (cToken.account.unclaimed_balance <= 0) continue;
          if (hasMempoolStakes(cToken.token.contract)) continue;
          nPendingStakes++;
        }
        if (nPendingStakes > 1) {
          domClaimAllBtn.style.display = "inline-block";
        } else if (domClaimAllBtn.style.display !== "none") {
          domClaimAllBtn.style.display = "none";
        }
      }
    }

    function copyToClipboard(text, name) {
      clipboard.writeText(text);
      M.toast({html: name + ' copied to Clipboard!', displayLength: 2000});
    }

    function openExternalURL(url) {
      require("electron").shell.openExternal(url);
    }

    function showFileInExplorer(path) {
      require("electron").shell.showItemInFolder(path);
    }

    function formatName(name, limit) {
      return (name.length > limit ? name.substr(0, limit) + "…" : name);
    }

    function percentOf(partial, full) {
      return (partial / full) * 100;
    }

    function percentChange(decrease, oldNumber) {
      return (decrease / oldNumber) * 100;
    }

    const sleep = (milliseconds) => {
      return new Promise(resolve => setTimeout(resolve, milliseconds));
    }

    setInterval(() => {
      // Check block count + UTXO sync every 10 seconds
      getBlockCount();
      if (WALLET.getActiveWallet().getPubkey()) {
        getUnspentTransactions();
        if (isFullnodePtr()) {
          getMempoolActivity(WALLET.getActiveWallet().getPubkey()).then(updateMempoolActivity);
        }
      }
      // Update Dashboard stats
      if (valueUSD > 0) {
        domBalanceUSD.innerText = (getBalance() * valueUSD).toFixed(2);
        domPrice.innerText = "$" + valueUSD.toFixed(2);
        if (currentSupply > 0)
          domMarketcap.innerText = "$" + (currentSupply * valueUSD).toLocaleString('en-GB', { maximumFractionDigits: 0});
      }
      // Fetch price and supply info
      getCoinValue();
      getCoinSupply();
    }, 10000);

    // Refresh syncing status
    let syncStatusInterval = setInterval(refreshSyncStatus, 200);

    // Refresh 2FA system
    setInterval(refreshAuthenticator, 1000);

    onload = () => {
      // Cache all our UI elements
      domTheme = document.getElementById("themeSheet");
      domThemeButton = document.getElementById("themeButton");
      // Initialize theme from disk
      loadTheme();
      // Load settings from disk
      loadSettings();
      domHeader = document.getElementById("guiHeader");
      domLoginPage = document.getElementById("loginPage");
      domPass1Visibility = document.getElementById("pass1Visibility");
      domDashboardPage = document.getElementById('dashboardPage');
      domSendPage = document.getElementById('sendPage');
      domReceivePage = document.getElementById('receivePage');
      domAuthPage = document.getElementById('authPage');
      domStakingPage = document.getElementById('stakingPage');
      domSettingsPage = document.getElementById('settingsPage');
      domAuthDisplay = document.getElementById('authDisplay');
      domAuthImport = document.getElementById('authImport');
      domAuthTitle = document.getElementById('authTitle');
      domReceiveAddress = document.getElementById("receiveAddress");
      domAuthCode = document.getElementById("authCode");
      domAuthTime = document.getElementById("authTime");
      domAuthReset = document.getElementById("authReset");
      domBalance = document.getElementById("guiBalance");
      domBalanceUSD = document.getElementById("balanceUSD");
      domSendingBalance = document.getElementById("sendingCoinBalance");
      domPrice = document.getElementById("dashboardPrice");
      domMarketcap = document.getElementById("dashboardMarketcap");
      domBlock = document.getElementById("dashboardBlock");
      domDashboardBtn = document.getElementById("dashboardBtn");
      domActivityList = document.getElementById("activityList");
      domActivitySCC = document.getElementById("domActivitySCC");
      domActivitySCP = document.getElementById("domActivitySCP");
      domClaimAllBtn = document.getElementById("domClaimAllBtn");
      domSendBtn = document.getElementById("sendBtn");
      domReceiveBtn = document.getElementById("receiveBtn");
      dom2FABtn = document.getElementById("2faBtn");
      dom2FAMenu = document.getElementById("2faBtnMenu");
      if (!display2FAMenu)
        dom2FAMenu.style.display = "none";
      domStakingTitle = document.getElementById("stakingTitle");
      domStakingSubtitle = document.getElementById("stakingSubtitle");
      domStakingApy = document.getElementById("stakingApy");
      domStakingRoi = document.getElementById("stakingRoi");
      domStakingRewards = document.getElementById("stakingRewards");
      domStakingRedeem = document.getElementById("stakingRedeem");
      // Don't need to cache these as it's just one-time use
      if (npmPackage) {
        document.getElementById("version").innerText = "v" + npmPackage.version;
        document.getElementById("versionLogin").innerText = "v" + npmPackage.version;
      } else {
        document.getElementById("version").style.display = "none";
        document.getElementById("versionLogin").style.display = "none";
      }
      switchToLogin();
      init().then(() => {
        // Check for an encrypted wallet, if one exists, pull up the login screen!
        let cWallet = WALLET.getActiveWallet() || new WALLET.Wallet();
        let encwif = false;
        if (cWallet && cWallet.getPrivkeyEnc())
          encwif = cWallet.getPrivkeyEnc();
        else
          localStorage.getItem("encwif");
        if (encwif && encwif.length > 1) {
          console.log("Encrypted key found: " + encwif);
          cWallet.setKeys(null, null, encwif);
          getUnspentTransactions();
        } else {
          // No encrypted wallet available, check for an unencrypted key
          let tmpwifkey = localStorage.getItem("tmpwifkey");
          let tmppass = localStorage.getItem("tmppass");
          if (!tmppass) throw "Unable to find encwif, and no tmppass available, bailing out!";
          console.log("Unable to find encrypted keys, but tmppass is available, checking for imported wifkey...");
          if (tmpwifkey) {
            console.log("Encrypting import key...");
            // Save decrypted copy in memory, immediately erase from disk
            cWallet.setKeys(null, tmpwifkey);
            // This looks strange, but it's happening for pointer-safety reasons, trust me
            cWallet = WALLET.addWallet(cWallet);
            console.log(cWallet);
            localStorage.removeItem("tmpwifkey");
            // Encrypt wallet and save it to disk
            encryptWallet(tmppass).then(newEncwif => {
              console.log("Encrypted wallet!");
              // Erase the tmppass from disk and memory
              tmppass = null;
              localStorage.removeItem("tmppass");
              // Load the new keys
              let strPubkey = WALLET.sccjs.pubFromPriv(WALLET.getActiveWallet().getPrivkey());
              cWallet.setKeys(strPubkey, null, newEncwif);
              DB.setWallet(WALLET.toDB());
              // Load the Dashboard screen
              switchToDashboard();
              // Give the cache a kick
              setTimeout(() => {
                getBalance(true);
              }, 750);
            });
          } else {
            console.log("Deriving new key...");
            WALLET.createWallet().then(objWallet => {
              // Save decrypted copy in memory
              cWallet.setKeys(objWallet.pubkey, objWallet.privkey);
              // Encrypt wallet and save it to disk
              encryptWallet(tmppass).then(newEncwif => {
                console.log("Encrypted wallet!");
                cWallet.setKeys(null, null, newEncwif);
                DB.setWallet(WALLET.toDB());
                // Erase the tmppass from disk and memory
                tmppass = null;
                localStorage.removeItem("tmppass");
                // Load the Dashboard screen
                switchToDashboard();
              });
            });
          }
        }
      });
    }
  </script>

  <main class="main-body">
    <div class="container marketing pt-navbar" id="dashboardPage">

      <h4 class="mb-5 theme-color-secondary font-weight-bold">Dashboard</h4>

      <div class="row">
        <div class="col-md-7">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Balance<span
                  id="balanceRefresh" onclick="getBlockCount(); getUnspentTransactions(); getBalance(true);" class="float-end theme-color refresh-button reload"><i class="fas fa-redo-alt"></i></span></div>
              <div class="mt-4 theme-color-secondary font-weight-bold">
                <div class="float-end"><span id="guiBalance" class="font-balance">...</span> <span
                    class="font-size-ticker">SCC</span></div><br><br>
                <div class="float-end balance-usd-props"><span
                    id="balanceUSD" class="font-balance-usd font-gray font-weight-normal">...</span> <span
                    class="font-size-ticker-usd font-gray font-weight-normal">USD</span></div>
              </div>
            </div>
          </div>

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Activity</div>
              <span id="domActivitySCC" onclick="setActivityView(false);" style="cursor: pointer; opacity: 0.4;" class="badge badge-theme">SCC</span>
              <span id="domActivitySCP" onclick="setActivityView(true);" style="cursor: default;" class="badge badge-theme">SCP</span>
              <div id="activityList" style="overflow-y: auto; max-height: 320px; padding-right: 10px;">
                <center style='margin-top:30px;'><p>You have no activity!</p></center>
              </div>
            </div>
          </div>

        </div>
        <div class="col-md-5">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Overview</div>
              <div class="mt-4 theme-color-secondary font-weight-bold font-size-overview">
                <span class="font-gray">Price:</span>
                <span class="float-end" id="dashboardPrice">Loading...</span><br>
                <span class="font-gray">Marketcap:</span>
                <span class="float-end" id="dashboardMarketcap">Loading...</span><br>
                <span class="font-gray">Current Block:</span>
                <span class="float-end" id="dashboardBlock">Loading...</span>
              </div>
            </div>
          </div>

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold" style="margin-bottom:10px;">SCP Tokens</div>
              <span id="domClaimAllBtn" onclick="claimAll();" style="display: none; cursor: pointer;" class="badge badge-theme">Claim All</span>
              <div id="dashboardTokens" style="overflow-y: auto; max-height: 200px; padding-right: 10px; margin-top: 10px;">
                <center><p>Loading SCP</p></center>
              </div>
            </div>
          </div>

        </div>
      </div>


    </div>

    <div class="container marketing pt-navbar" id="sendPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Send</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Withdraw</div>

              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> &nbsp;Please make sure to enter the correct address. Transactions cannot be reversed.</div><br>

              <div class="row">
                <div class="col-sm-12">
                  <select id="sendingCoin" class="vodiapicker">
                    <option value="" data-thumbnail="imgs/i.png" disabled selected hidden>-</option>
                    <option value="scc" data-thumbnail="imgs/circular-logo.png">StakeCubeCoin (SCC)</option>
                  </select>
                  <p>Select Token:</p>
                  <div class="lang-select">
                    <button id="sendingCoinVal" class="btn-select" value="scc"></button>
                    <div class="b" style="z-index:1000;">
                      <ul id="a"></ul>
                    </div>
                  </div>
                </div>
              </div><br>

              <div class="row">
                <div class="col-md-6" style="margin: 20px 0;">
                  <div class="omrs-input-group" style="width:100%; margin-bottom: 0px;">
                    <label class="omrs-input-underlined">
                      <input required id="sendAmount" type="text">
                      <span class="omrs-input-label">Amount</span>
                    </label>
                  </div>
                  <span style="font-size: 13px; top:5px; position: relative;">Available: <span id="sendingCoinBalance" onclick="autofillSendingAmount()" style="cursor: pointer;" class="badge badge-theme" style="margin-bottom:0px">-</label></span>
                </div>

                <div class="col-md-6" style="margin: 20px 0;">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required id="sendAddress" type="text">
                      <span class="omrs-input-label">SCC Address</span>
                    </label>
                  </div>
                </div>

                <div class="col text-end"><br>
                  <button class="btn btn-layout btn-theme" id="sendTx" onclick="sendTransactionGUI()">Send Transaction</button><br>
                </div>

                <script>
                  $("#sendTx").on("keydown", function(e){
                    if(e.keyCode === 13){
                      if (!allowEnterKey) e.preventDefault();
                    }
                  });
                </script>
              </div>
            </div>
          </div>

        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="receivePage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Receive</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Receive address</div>
              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> Please make sure to only send SCC or SCP tokens to this address. Other coins will be lost and cannot be reversed.</div><br>
              
              <center>
                <div onclick="copyToClipboard(WALLET.getActiveWallet().getPubkey(), 'Address')" class="refresh-button hover-darker">
                  <span id="receiveAddress" class="font-weight-bold"></span>
                  <span style="padding-left:6px;">
                    <i class="far fa-copy"></i>
                  </span>
                </div>
              </center>
              <br>
              <center><img id="receiveQR" style="width: 25%;height:auto;image-rendering:pixelated;"></center>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="authPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">StakeCube 2FA</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div id="authTitle" class="card-title font-gray font-weight-bold">Setup your 2FA</div>
                <div class="alert alert-danger-custom" style="font-size:13px;">
                  <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i>Do <b>not</b> share these codes with <b>anyone!</b>
                </div>
                <div class="alert alert-warning-custom" style="font-size:13px;">
                  <i class="fas fa-info-circle" style="margin-right: 6px;"></i> The 2FA screen can be used as an in-wallet 2FA app for your StakeCube.net account, if you haven't already setup 2FA on your StakeCube.net account, use this and secure your account with your wallet!<br><br>
                  To find your 2FA settings, login to StakeCube.net, visit your settings, and copy your 2FA "Secret", below the QR code, into the "Secret Code" section of this 2FA screen, then you're secured!
                </div><br>
                <div id="authImport">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required id="authSecretImport" type="text" autofocus>
                      <span class="omrs-input-label">2FA</span>
                    </label>
                  </div>
                  
                  <center><button onclick="import2FA()" style="margin-top: 10px;" class="btn btn-theme btn-layout">Import</button></center>
                  <br>
                </div>
                <center id="authDisplay">
                  <div onclick="copyToClipboard(document.getElementById('authCode').innerText, '2FA code')" class="refresh-button hover-darker">
                    <span id="authCode" style="font-size: x-large;" class="font-weight-bold"></span>
                    <i  style="padding-left:6px;" class="far fa-copy refresh-button"></i>
                  </div>
                  <p id="authTime" style="opacity: 0.8;">10 seconds left til next code</p>
                  <br>
                </center>
              <center id="authReset"><button onclick="remove2FA()" style="margin-top: 10px;" class="btn btn-danger btn-layout">Remove 2FA</button></center>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="stakingPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">SCP-2 Staking</h4>

      <center>
        <h3>Est. APR of <b id="stakingApy">---</b></h3>
      </center>
      <br>
      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold" id="stakingTitle">Loading...</div>
              <br>
              <center>
                <p id="stakingSubtitle">Loading...</p>
                <h2 id="stakingRewards">...</h2>
                <p id="stakingRoi" style="opacity:0.5;"></p>
                <br>
                <button id="stakingRedeem" class="btn btn-layout btn-theme disabled" onclick="redeemTokens()">Claim Rewards</button>
              </center><br><br>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container marketing pt-navbar" id="settingsPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Settings</h4>


      <div class="card card-prop mb-4">
        <div class="card-body">

          <div class="accordion" id="accordionExample">
            <div class="accordion-item">
              <h2 class="accordion-header" id="headingOne">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                  <span class="darkText">Personalization</span>
                </button>
              </h2>
              <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                  
                  <div class="row" style="display: none;">
                    <div class="col-9">
                      <span style="font-size:14px;">How many taco's do you want for dinner?</span><br>
                      <span style="font-size:11px; color:#97a1b1;">Basicly a description of the taco here</span>
                    </div>
                    <div class="col-3">
                      <select class="form-select form-select-sm" aria-label=".form-select-sm example">
                        <option selected>Open this select menu</option>
                        <option value="1">One</option>
                        <option value="2">Two</option>
                        <option value="3">Three</option>
                      </select>
                    </div>
                  </div>
                  
                  <hr style="color: #bcc4d2; display: none;">

                  <div class="row">
                    <div class="col-9">
                      <span>Allow 'Enter' key to continue actions</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will mean hitting 'Enter' will not perform or continue any actions or dialogs.<br>This setting is ignored on all Password fields.</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="allowEnterKeySetting" checked="true" setting="allowEnterKey" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Display the 2FA menu</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will hide the 2FA button from the header menu.<br>This will not remove or lose any 2FA codes, only hide them visually.</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="display2FAMenuSetting" checked="true" setting="display2FAMenu" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Limit Activity to 200 TXs</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will let the Activity display unlimited TXs, however this may cause performance issues on large wallets.</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="limitActivitySetting" checked="true" setting="limitActivity" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Hide Empty Wallets</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will display empty (0-balance) wallets in their respective area.</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="hideZeroBalanceSetting" checked="true" setting="hideZeroBalance" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="accordion-item">
              <h2 class="accordion-header" id="headingTwo">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="true" aria-controls="collapseTwo">
                  <span class="darkText">Wallet</span>
                </button>
              </h2>
              <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                  <div class="row">
                    <div class="col-sm-9">
                      <span>Export Wallet</span><br>
                      <span style="font-size:12px; color:#97a1b1;">This will highlight your private wallet file in your file explorer. You can use this file to move your wallet to another device, or as an encrypted backup method. (Contains: Encrypted Privkey, Pubkey & 2FA secret)</span>
                    </div>
                    <div class="col-sm-3">
                      <div class="container" style="padding: 10px 0;">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <button class="btn btn-primary" onclick="showFileInExplorer(DB.appdata.getAppDataPath('SCPWallet\\wallet.json'))" style="width: 100%; min-width: 80px;">Export</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
    <i id="themeButton" onclick="loadNextTheme();" class="fas fa-sun" style="position: fixed; bottom: 10px; left: 10px; color: black; opacity: 0.5; cursor: pointer;"></i>
  </main>

  <!-- Materialize Library -->
  <script type="text/javascript" src="js/materialize.js"></script>

  <script src="js/bootstrap.bundle.min.js"></script>
  <script src="js/select.js"></script>

</body>

</html>